	OUTPUT	neo48.rom
	SIZE	4000H

	MACRO PADTO addr ; z80asm "FORG" replacement
		; add padding + display warning
		IF $ > addr
			; no padding
			DISPLAY /L, "Warning! PADTO failed! ", $, " is more than ", addr
		ELSE
			; add padding
			BLOCK addr-$
		ENDIF
		ORG	addr
	ENDM

	DEFINE	R_RESET	$00
	DEFINE	R_1	$08
	DEFINE	R_2	$10
	DEFINE	R_3	$18
	DEFINE	R_4	$20
	DEFINE	R_5	$28
	DEFINE	R_ERR	$30
	DEFINE	R_MATH	$38

	DEFINE	ERR_INT_OPCODE	$01
	DEFINE	ERR_INT_INVALID	$02
	DEFINE	ERR_RUN_OVERFL	$11

; Alternativelyâ€¦ use AF' (flags) to store previous boolean result.

	PADTO	$0080
interpreter:
	ld	b, (GENERAL_LUT >> 8)
	ex	de, hl
	jp	interpret_next

	MACRO	INTERPRET_NEXT
	; Main fetch/decode part is 8 bytes, 46 tstates
	ld	a, (de)
	inc	de
	ld	h, (GENERAL_LUT >> 8)	; Holds MSB of opcode LUT, and interpreter code is at b * 2
	ld	l, a
	ld	l, (hl)
	add	hl, hl  ; If we could squeeze all main interpreter code into 256 bytes, we could change to "inc h" and save 7 t-states
	jp	(hl)
	ENDM

interpret_next_inc1:
	inc	de
interpret_next:
	INTERPRET_NEXT

; Main fetch/decode part is 9 bytes, 39 tstates
interpret_false:
	ld	a, (de)
	inc	de
	ld	b, a
	and	$f8
	ld	h, FALSE_OPS>>8
	ld	l, a
	jp	(hl)

; Main fetch/decode part is 9 bytes, 39 tstates
interpret_true:
	ld	a, (de)
	inc	de
	ld	b, a
	and	$f8
	ld	h, TRUE_OPS>>8
	ld	l, a
	jp	(hl)

;------------------------------------------------

	DEFINE	GENERAL_OPS	$200
	MACRO GENERAL code
		IF (code - GENERAL_OPS) % 2 != 0
			DISPLAY /L, "Warning! Opcode routine ", $ - GENERAL_LUT, " is not aligned."
		ENDIF
		DB	(code - GENERAL_OPS) / 2
	ENDM
	MACRO GENERALx16 code
		IF (code - GENERAL_OPS) % 2 != 0
			DISPLAY /L, "Warning! Opcode routine ", $ - GENERAL_LUT, " is not aligned."
		ENDIF
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
		DB	(code - GENERAL_OPS) / 2
	ENDM
	MACRO GENERAL_AT opcode_offset
		BLOCK	opcode_offset - ($ - GENERAL_LUT)
	ENDM


	PADTO	$0100
GENERAL_LUT:
	GENERAL_AT $00
	GENERAL(statement_nop)	; 00 NOP
	GENERAL(statement_nop)	; 01 line-continuation
	GENERAL(statement_nop)	; 02 end-if
	GENERAL(statement_nop)	; 03 else
	GENERAL(statement_nop)	; 04 parens

	GENERAL_AT $0f
	GENERAL(statement_halt)

	GENERAL_AT $1C
	GENERAL(literal_false_stack)	; 1c
	GENERAL(literal_true_stack)	; 1d
	GENERAL(literal_false_immediate)	; 1e
	GENERAL(literal_true_immediate)	; 1f

	GENERAL_AT $20
	GENERAL(literal_0int16)	; 20
	GENERAL(literal_0int32)	; 21
	GENERAL(literal_1int16)	; 22
	GENERAL(literal_1int32)	; 23

	GENERAL_AT $30

	GENERAL_AT $40 ; int16 operations
	GENERAL(statement_int16_eq)	; 40
	GENERAL(statement_int16_ne)	; 41
	GENERAL(statement_int16_gt)	; 42
	GENERAL(statement_int16_ge)	; 43
	GENERAL(statement_int16_lt)	; 44
	GENERAL(statement_int16_le)	; 45
	GENERAL(statement_int16_add)	; 46
	GENERAL(statement_int16_sub)	; 47
	GENERAL(statement_int16_mul)	; 48
	GENERAL(statement_int16_div)	; 49
	GENERAL(statement_int16_mod)	; 4a
	GENERAL(statement_int16_bitand)	; 4b
	GENERAL(statement_int16_bitor)	; 4c
	GENERAL(statement_int16_bitxor)	; 4d
	GENERAL(statement_int16_bitshl)	; 4e
	GENERAL(statement_int16_bitshr)	; 4f

	GENERAL_AT $50

	GENERAL_AT $60

	GENERAL_AT $70

	GENERAL_AT $80
	GENERALx16(statement_jumpfwd)	; endif

	GENERAL_AT $90
	GENERALx16(statement_for)	; for

	GENERAL_AT $A0
	GENERALx16(statement_jumpfwd)	; break

	GENERAL_AT $B0
	GENERALx16(statement_jumpback)	; continue

	GENERAL_AT $C0
	GENERALx16(statement_jumpback)	; endloop

	GENERAL_AT $D0

	GENERAL_AT $E0 ; 2-byte literals
	GENERAL(statement_literalint16)	; E0
	GENERAL(statement_literalint16)	; E1
	GENERAL(statement_literalint16)	; E2

	GENERAL_AT $f0

	PADTO	$0200
;GENERAL_OPS:
statement_error:
	RST	R_ERR
	BYTE	ERR_INT_OPCODE

statement_load16:
statement_load32:
statement_store16:
statement_store32:

	ALIGN	2
statement_nop:
	jp	interpret_next

	ALIGN	2
literal_false_stack:
	jp	false_push

	ALIGN	2
literal_true_stack:
	jp	true_push

	ALIGN	2
literal_false_immediate:
	jp	interpret_false

	ALIGN	2
literal_true_immediate:
	jp	interpret_true

	ALIGN	2
literal_0int16
	sbc	hl,hl
	push	hl
	jp	interpret_next

	ALIGN	2
literal_1int16
	sbc	hl,hl
	inc	l
	push	hl
	jp	interpret_next

	ALIGN	2
literal_0int32
	sbc	hl,hl
	push	hl
	push	hl
	jp	interpret_next

	ALIGN	2
literal_1int32
	sbc	hl,hl
	push	hl
	inc	l
	push	hl
	jp	interpret_next

	ALIGN	2
statement_int16_eq:
	pop	hl
	pop	bc
	sbc	hl, bc
	jp	nz, interpret_false
	jp	interpret_true

statement_int16_ne:
	pop	hl
	pop	bc
	sbc	hl, bc
	jp	z, interpret_false
	jp	interpret_true

statement_int16_gt:
statement_int16_ge:
statement_int16_lt:
statement_int16_le:

	ALIGN 2
statement_int16_add:
	pop	hl
	pop	bc
	add	hl, bc
	push	hl
	jp	po, interpret_next
	rst	R_ERR
	BYTE	ERR_RUN_OVERFL

	ALIGN 2
statement_int16_sub:
	pop	bc
	pop	hl
	sbc	hl, bc
	push	hl
	jp	po, interpret_next
	rst	R_ERR
	BYTE	ERR_RUN_OVERFL

	ALIGN 2
statement_literalint16:
	ld	a, (de)
	inc	de
	ld	l, a
	ld	a, (de)
	ld	h, a
	push	hl
	jp	interpret_next_inc1

	ALIGN 2
statement_int16_mul:
statement_int16_div:
statement_int16_mod:
statement_int16_bitand:
statement_int16_bitor:
statement_int16_bitxor:
statement_int16_bitshl:
statement_int16_bitshr:
statement_endif:
statement_for:
statement_break:
statement_continue:


statement_halt:
	halt

	ALIGN 2
statement_jumpfwd:	; 5 bytes, 22 tstates (excluding common part)
	and	$0f
	jp	common_jump
	ALIGN 2
statement_jumpback:	; 5 bytes, 22 tstates (excluding common part)
	or	$f0
common_jump:	; 4 bytes, 26 tstates
	ex	de, hl
	ld	d, a
	ld	e, (hl)	; do NOT inc de because we immediately jump
	add	hl, de
	ex	de, hl
	; then a copy of "interpret_next"
	INTERPRET_NEXT
;------------------------------------------------
	PADTO	$0400
FALSE_OPS:

false_discard:
	PADTO	FALSE_OPS+$00
	INTERPRET_NEXT

false_parens:
	PADTO	FALSE_OPS+$08
	jp	interpret_false

false_eq:	; 8 bytes, 34 tstates
	PADTO	FALSE_OPS+$10
	pop	af
	or	a
	jp	nz, interpret_false
	jp	interpret_true

false_ne:	; 8 bytes, 34 tstates
	PADTO	FALSE_OPS+$18
	pop	af
	or	a
	jp	nz, interpret_false
	jp	interpret_true

false_not:
	PADTO	FALSE_OPS+$20
	jp	interpret_true

false_shortcircuit_and:
	PADTO	FALSE_OPS+$28
	xor	a
	jp	common_jump

false_shortcircuit_or:
	PADTO	FALSE_OPS+$30
	jp	interpret_next_inc1

false_push:
	PADTO	FALSE_OPS+$50
	ld	l, %11111000
	push	hl
	INTERPRET_NEXT

false_statement_if:	; 7 bytes, 25 tstates
	PADTO	FALSE_OPS+$80
	ld	a, b
	and	$0f
	jp	common_jump

	PADTO	FALSE_OPS+$88
	ld	a, b
	and	$0f
	jp	common_jump

false_statement_elseif:	; 7 bytes, 25 tstates
	PADTO	FALSE_OPS+$90
	ld	a, b
	and	$0f
	jp	common_jump

	PADTO	FALSE_OPS+$98
	ld	a, b
	and	$0f
	jp	common_jump

false_statement_while:	; 7 bytes, 25 tstates
	PADTO	FALSE_OPS+$a0
	ld	a, b
	and	$0f
	jp	common_jump

	PADTO	FALSE_OPS+$a8
	ld	a, b
	and	$0f
	jp	common_jump

false_statement_break:	; 7 bytes, 25 tstates
	PADTO	FALSE_OPS+$b0
	jp	interpret_next_inc1

	PADTO	FALSE_OPS+$b8
	jp	interpret_next_inc1

false_statement_continue:	; 7 bytes, 25 tstates
	PADTO	FALSE_OPS+$c0
	jp	interpret_next_inc1

	PADTO	FALSE_OPS+$c8
	jp	interpret_next_inc1

;------------------------------------------------
	PADTO	$0500
TRUE_OPS:

true_discard:
	PADTO	TRUE_OPS+$00
	INTERPRET_NEXT

true_parens:
	PADTO	TRUE_OPS+$08
	jp	interpret_true

true_eq:	; 7 bytes, 30 tstates
	PADTO	TRUE_OPS+$10
	pop	af
	jp	z, interpret_false
	jp	interpret_true

true_ne:	; 7 bytes, 30 tstates
	PADTO	TRUE_OPS+$18
	pop	af
	jp	nz, interpret_false
	jp	interpret_true

true_not:
	PADTO	TRUE_OPS+$20
	jp	interpret_false

true_shortcircuit_and:
	PADTO	TRUE_OPS+$28
	jp	interpret_next_inc1

true_shortcircuit_or:
	PADTO	TRUE_OPS+$30
	xor	a
	jp	common_jump

true_push:
	PADTO	TRUE_OPS+$50
	ld	l, %00000111
	push	hl
	INTERPRET_NEXT

true_statement_if:	; 7 bytes, 25 tstates
	PADTO	TRUE_OPS+$80
	jp	interpret_next_inc1

	PADTO	TRUE_OPS+$88
	jp	interpret_next_inc1

true_statement_elseif:
	PADTO	TRUE_OPS+$90
	jp	interpret_next_inc1

	PADTO	TRUE_OPS+$98
	jp	interpret_next_inc1

true_statement_while:
	PADTO	TRUE_OPS+$a0
	jp	interpret_next_inc1

	PADTO	TRUE_OPS+$a8
	jp	interpret_next_inc1

true_statement_break:
	PADTO	TRUE_OPS+$b0
	and	$0f
	jp	common_jump

	PADTO	TRUE_OPS+$b8
	and	$0f
	jp	common_jump

true_statement_continue:
	PADTO	TRUE_OPS+$c0
	or	$f0
	jp	common_jump

	PADTO	TRUE_OPS+$c8
	or	$f0
	jp	common_jump

