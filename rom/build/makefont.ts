import { glyphs, type Glyph } from '@zx/fonts'
import { Charset } from '@zx/sys'
import * as process from 'node:process'

interface Writeable {
	write(chunk: string, callback?: (error: Error | null | undefined) => void): boolean;
}
const outfile: Writeable = process.stdout
writeFile(outfile)

function writeFile(out: Writeable){
	out.write("	; FONT TABLES\n")
	out.write("	; AUTOGENERATED\n\n")
	writeFontTo(out, glyphs)
}

function writeFontTo(out: Writeable, font: Record<number, Glyph>){
	let min = 255, max = 0
	for (let c = 0; c < 256; c++) {
		if (font[c]) {
			min = Math.min(c, min)
			max = Math.max(c, max)
		}
	}
	if (min > max) throw "No glyphs found in the font!"
	const count = max - min + 1

	const encoded: EncodedGlyph[] = []
	for (let c = min; c <= max; c++){
		encoded.push(encodedChar(c, font[c]))
	}

	out.write("FONT_LOOKUP:\n")
	out.write(`	DB	${hex(min)}	; First glyph codepoint\n`)
	out.write(`	DB	${hex(count - 1)}	; Index of last glyph (= count - 1)\n`)
	let offset = 0
	let minDelta = 0, maxDelta = 0
	for (let i = 0; i < count; i++) {
		const toFontData = (count - i) * 2
		const enc = encoded[i]
		const dataPointer = enc.bytes ? offset : 0
		const c = enc.codepoint
		const w = enc.width ?? encoded[0].width
		const delta = dataPointer - (i * 6)
		minDelta = Math.min(delta, minDelta)
		maxDelta = Math.max(delta, maxDelta)
		out.write(`	DW	(${toFontData} + ${dataPointer}) | (${w} << 14)	; character ${c} (${hex(c)} ‘${repr(c)}’)   delta ${delta}\n`)
		offset += enc.bytes?.length ?? 0
	}
	out.write(`	; delta from 6* = [${minDelta}..${maxDelta}]\n`)
	out.write("\n")
	out.write("FONT_DATA:\n")
	for (const enc of encoded) {
		const c = enc.codepoint
		const bytes = enc.bytes
		if (!bytes) continue

		out.write(`	; character ${c} (${hex(c)} ‘${repr(c)}’)\n`)
		out.write(`	DB	${hex(bytes[0])}`)
		for (let i = 1; i < bytes.length; i++) {
			out.write(`, ${hex(bytes[i])}`)
		}
		out.write('\n\n')
	}
}

function repr(codepoint: number): string {
	const unicode = Charset[codepoint]
	const u = unicode.charCodeAt(0)
	if (u >= 32) return unicode
	switch(u) {
		case 9: return '\\t'
		case 10: return '\\n'
		case 13: return '\\r'
		default: return '\\x' + u.toString(16)
	}
}

interface EncodedGlyph {
	codepoint: number
	width?: 0|1|2|3
	bytes?: number[]
}

function encodedChar(codepoint: number, glyph: Glyph): EncodedGlyph {
	if (!glyph) return { codepoint: codepoint }

	const raw = glyph.bytes
	const encoded: number[] = []
	const nWidth = glyph.width == 'h' ? 1 : glyph.width == 'n' ? 2 : 3

	let firstPixelLine = 8, lastPixelLine = 0
	for (let i = 0; i < 8; i++) {
		const hasPixels = raw[i * 2 + 0] != 0 || raw[i * 2 + 1] != 0
		if (hasPixels) {
			firstPixelLine = Math.min(i, firstPixelLine)
			lastPixelLine = Math.max(i, lastPixelLine)
		}
	}
	const noPixels = (firstPixelLine > lastPixelLine)

	const leading = noPixels ? 1 : firstPixelLine
	const originalHeight = noPixels ? 0 : (lastPixelLine - firstPixelLine + 1)
	const height = Math.min(originalHeight, 8)

	const charInfo = (height << 3) | (leading << 0)
	encoded.push(charInfo)
	switch (nWidth) {
		case 1:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				const b = raw[ix] & 0xf0
				encoded.push(b | (b >> 4))
			}
			break;
		case 2:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix] & 0xff)
			}
			break;
		case 3:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix + 0] & 0xff)
				encoded.push(raw[ix + 1] & 0xf0)
			}
			break;
	}

	return { codepoint, bytes: encoded, width: nWidth }
}

function hex(n: number): string {
	return '$' + n.toString(16)
}
