import { glyphs, Glyph } from '@zx/fonts'
import { Charset } from '@zx/sys'
import * as process from 'node:process'

interface Writeable {
	write(chunk: any, callback?: (error: Error | null | undefined) => void): boolean;
}
const outfile: Writeable = process.stdout
writeFile(outfile)

async function writeFile(out: Writeable){
	out.write("	; FONT TABLES\n")
	out.write("	; AUTOGENERATED\n\n")
	writeFontTo(out, glyphs)
}

function writeFontTo(out: Writeable, font: Record<number, Glyph>){
	let min = 255, max = 0
	for (let c = 0; c < 256; c++) {
		if (font[c]) {
			min = Math.min(c, min)
			max = Math.max(c, max)
		}
	}
	if (min > max) throw "No glyphs found in the font!"
	const count = max - min + 1

	const encoded: EncodedGlyph[] = []
	for (let c = min; c <= max; c++){
		encoded.push(encodedChar(c, font[c]))
	}

	out.write("FONT_LOOKUP:\n")
	out.write(`	DB	${hex(min)}	; First glyph codepoint\n`)
	out.write(`	DB	${hex(count)}	; Glyph count\n`)
	const tableSize = 1 + 1 + 2 * count
	let offset = 0
	let minDelta = 0, maxDelta = 0, i = 0
	for (let enc of encoded) {
		const c = enc.codepoint
		const delta = offset - (i * 6)
		minDelta = Math.min(delta, minDelta)
		maxDelta = Math.max(delta, maxDelta)
		out.write(`	DW	(FONT_DATA + ${offset})	; character ${c} (${hex(c)}  ‘${Charset[c]}’)   delta ${delta}\n`)
		offset += enc.bytes.length
		i ++
	}
	out.write(`	; delta from 6* = [${minDelta}..${maxDelta}]\n`)
	out.write("\n")
	out.write("FONT_DATA:\n")
	for (let enc of encoded) {
		const c = enc.codepoint
		const bytes = enc.bytes
		out.write(`	; character ${c} (${hex(c)}  ‘${Charset[c]}’)\n`)
		out.write(`	DB	${hex(bytes[0])}`)
		for (let i = 1; i < bytes.length; i++) {
			out.write(`, ${hex(bytes[i])}`)
		}
		out.write('\n\n')
	}
}

interface EncodedGlyph {
	codepoint: number,
	bytes: number[]
}

function encodedChar(codepoint: number, glyph: Glyph): EncodedGlyph {
	const raw = glyph.bytes
	const encoded: number[] = []
	const nWidth = glyph.width == 'h' ? 1 : glyph.width == 'n' ? 2 : 3

	let firstPixelLine = 8, lastPixelLine = 0
	for (let i = 0; i < 8; i++) {
		const hasPixels = raw[i * 2 + 0] != 0 || raw[i * 2 + 1] != 0
		if (hasPixels) {
			firstPixelLine = Math.min(i, firstPixelLine)
			lastPixelLine = Math.max(i, lastPixelLine)
		}
	}
	const noPixels = (firstPixelLine > lastPixelLine)

	const leading = noPixels ? 1 : firstPixelLine
	const originalHeight = noPixels ? 0 : (lastPixelLine - firstPixelLine + 1)
	const height = Math.min(originalHeight, 7)

	const charInfo = (nWidth << 6) | (leading << 3) | (height << 0)
	encoded.push(charInfo)
	switch (nWidth) {
		case 1:
			const mask = nWidth == 1 ? 0xf0 : 0xff
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				const b = raw[ix] & 0xf0
				encoded.push(b | (b >> 4))
			}
			break;
		case 2:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix] & 0xff)
			}
			break;
		case 3:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix + 0] & 0xff)
				encoded.push(raw[ix + 1] & 0xf0)
			}
			break;
	}

	return { codepoint, bytes: encoded }
}

function hex(n: number): string {
	return '$' + n.toString(16)
}

interface Writeable {
	write(chunk: any, callback?: (error: Error | null | undefined) => void): boolean;
}

async function write(out: Writeable, str: string): Promise<void> {
	return new Promise((resolve, reject) => {
		out.write(str, (anyError: Error|null) => {
			if (anyError) reject(anyError); else resolve()
		})
	})
}