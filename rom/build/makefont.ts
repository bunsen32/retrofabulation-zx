import { glyphs, type VisibleGlyph, type Glyph } from '@zx/fonts'
import { Charset } from '@zx/sys'
import * as process from 'node:process'

const firstUdg = 0xe0
const lastUdg = 0xef
const UDG_RAM_START = 0x5B70	// TODO: Could position just BEFORE the other globals?

interface Writeable {
	write(chunk: string, callback?: (error: Error | null | undefined) => void): boolean
}
const outfile: Writeable = process.stdout
writeFile(outfile)

function writeFile(out: Writeable){
	out.write("	; FONT TABLES\n")
	out.write("	; AUTOGENERATED\n\n")
	writeFontTo(out, glyphs)
}

function writeFontTo(out: Writeable, font: Record<number, Glyph>){
	const allEncoded = encodeAll(font)
	const count = allEncoded.lastChar - allEncoded.firstChar + 1
	if (count <= 0) throw "No glyphs found in the font!"

	const ordered = reorderForUdg(allEncoded.orderedGlyphData)
	const codepointDataOffsets: Record<number, number> = []
	const characterWidths: Record<number, number> = []
	let offset = 0
	for(const glyph of ordered) {
		for (const codepoint of glyph.codepoints) {
			codepointDataOffsets[codepoint] = offset
			characterWidths[codepoint] = glyph.width
		}
		offset += glyph.bytes.length
	}
	const pixelDataSize = offset + (128 /*TODO: remove this hack!*/)
	const min = allEncoded.firstChar
	const firstGlyphWidth = characterWidths[min]
	if (firstGlyphWidth === undefined) throw "Failed assertion: first glyph must always have a width!"

	adjustUdgOffsets(codepointDataOffsets, pixelDataSize)
	const font_size = pixelDataSize + (count * 2) + 2
	
	out.write(`	PADTO	$4000 - ${font_size}	; Position just before the end of ROM\n`)
	out.write("FONT_LOOKUP:\n")
	out.write(`	DB	${hex(min)}	; First glyph codepoint\n`)
	out.write(`	DB	${hex(count - 1)}	; Index of last glyph (= count - 1)\n`)
	for (let i = 0; i < count; i++) {
		const toFontData = (count - i) * 2
		const c = min + i
		const dataPointer = codepointDataOffsets[c] ?? 0
		const w = characterWidths[c] ?? firstGlyphWidth
		out.write(`	DW	(${toFontData} + ${dataPointer}) | (${w} << 14)	; character ${c} (${hex(c)} ‘${repr(c)}’)\n`)
	}
	out.write("\n")
	out.write("FONT_DATA:\n")
	for (const enc of ordered) {
		const bytes = enc.bytes

		if (enc.codepoints.has(firstUdg)) {
			out.write('.udg_start:\n')
		}
		for(const c of enc.codepoints) {
			out.write(`	; character ${c} (${hex(c)} ‘${repr(c)}’)\n`)
		}
		out.write(`	DB	${hex(bytes[0])}`)
		for (let i = 1; i < bytes.length; i++) {
			out.write(`, ${hex(bytes[i])}`)
		}
		out.write('\n\n')
	}
}

function repr(codepoint: number): string {
	const unicode = Charset[codepoint]
	const u = unicode.charCodeAt(0)
	if (u >= 32) return unicode
	switch(u) {
		case 9: return '\\t'
		case 10: return '\\n'
		case 13: return '\\r'
		default: return '\\x' + u.toString(16)
	}
}

interface EncodedGlyph {
	codepoints: Set<number>
	width: 0|1|2|3
	bytes: number[]
}


interface FullEncoding {
	orderedGlyphData: EncodedGlyph[]
	firstChar: number
	lastChar: number
}

function encodeAll(repertoire: Record<number,Glyph>): FullEncoding {
	let min = 256
	let max = 0
	const glyphs: EncodedGlyph[] = []
	const lookup: (EncodedGlyph|undefined)[] = []

	for(let i = 0; i < 256; i ++) {
		const glyph = repertoire[i]
		const isVisible = !!glyph && 'bytes' in glyph
		const isSameas = !!glyph && 'sameas' in glyph
		const isMissing = !(isVisible || isSameas)
		if (isMissing) continue

		min = Math.min(min, i)
		max = Math.max(max, i)
		if (isVisible) {
			const encoded = encodedChar(i, glyph)
			glyphs.push(encoded)
			lookup[i] = encoded

		} else if (isSameas) {
			const sameas = glyph.sameas
			if (sameas == i) throw `Glyph ${i} cannot be ‘sameas’ itself.`
			if (sameas > i) throw `Forward references (${i} -> ${sameas}) are not currently supported.`
			const existing = lookup[glyph.sameas]
			if (!existing) throw `Glyph ${i} marked ‘sameas’ nonexistent glyph ${sameas}`
			existing.codepoints.add(i)
		}
	}

	return {
		orderedGlyphData: glyphs,
		firstChar: min,
		lastChar: max
	}
}

function encodedChar(codepoint: number, glyph: VisibleGlyph): EncodedGlyph {
	const raw = glyph.bytes
	const encoded: number[] = []
	const nWidth = glyph.width == 'h' ? 1 : glyph.width == 'n' ? 2 : 3

	let firstPixelLine = 8, lastPixelLine = 0
	for (let i = 0; i < 8; i++) {
		const hasPixels = raw[i * 2 + 0] != 0 || raw[i * 2 + 1] != 0
		if (hasPixels) {
			firstPixelLine = Math.min(i, firstPixelLine)
			lastPixelLine = Math.max(i, lastPixelLine)
		}
	}
	const noPixels = (firstPixelLine > lastPixelLine)

	const leading = noPixels ? 1 : firstPixelLine
	const originalHeight = noPixels ? 0 : (lastPixelLine - firstPixelLine + 1)
	const height = Math.min(originalHeight, 8)

	const charInfo = (height << 3) | (leading << 0)
	encoded.push(charInfo)
	switch (nWidth) {
		case 1:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				const b = raw[ix] & 0xf0
				encoded.push(b | (b >> 4))
			}
			break;
		case 2:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix] & 0xff)
			}
			break;
		case 3:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix + 0] & 0xff)
				encoded.push(raw[ix + 1] & 0xf0)
			}
			break;
	}

	return { codepoints: new Set([codepoint]), bytes: encoded, width: nWidth }
}

function hex(n: number): string {
	return '$' + n.toString(16)
}

/**
 * Reorders glyphs such that all the User Defined Graphics glyphs are sorted together, in order.
 * @param naivelyOrdered The Glyphs in their original order of appearance.
 * @returns The same glyphs, reordered.
 */
function reorderForUdg(naivelyOrdered: EncodedGlyph[]): EncodedGlyph[] {
	const beforeUdg: EncodedGlyph[] = []
	const udg: EncodedGlyph[] = []
	const afterUdg: EncodedGlyph[] = []
	let countedUdg = 0

	for(const glyph of naivelyOrdered) {
		const udgCodepoint = userDefinedGraphicCodepoint(glyph.codepoints)
		if (udgCodepoint) {
			udg[udgCodepoint - firstUdg] = glyph
			countedUdg += 1

		} else if (!countedUdg) {
			beforeUdg.push(glyph)
		} else {
			afterUdg.push(glyph)
		}
	}
	if (countedUdg !== (lastUdg - firstUdg + 1)) throw `Only found ${countedUdg} User Defined Graphics characters defined.`
	if (countedUdg !== udg.length) throw `Failed assertion: found ${countedUdg} UDGs but ${udg.length} items in array`

	return [...beforeUdg, ...udg, ...afterUdg]

	function userDefinedGraphicCodepoint(codepoints: Set<number>): number|undefined {
		for(const n of codepoints) {
			if (n >= firstUdg && n <= lastUdg) return n
		}
		return undefined
	}
}

function adjustUdgOffsets(codepointDataOffsets: Record<number, number>, pixelDataSize: number) {
	// Address (in ROM) where all of the pixel data is stored. Our offsets are initially relative to this:
	const romDataAddress = 0x4000 - pixelDataSize
	const offsetToFirstUdgGlyph = UDG_RAM_START - romDataAddress

	let offset = offsetToFirstUdgGlyph
	for(let c = firstUdg; c <= lastUdg; c++) {
		if (!codepointDataOffsets[c]) throw `Did not have glyph or ‘sameas’ defined for UDG ${c - firstUdg}`
		codepointDataOffsets[c] = offset
		offset += 9 // Each UDG character is 1 byte of metadata + 8 byte lines of pixel data.
	}
}
