import { Glyph, glyphs } from '../font1'
import { Charset } from '../encoding'
import { createWriteStream, WriteStream } from 'fs'
import * as process from 'process'

if (process.argv.length === 2) {
	console.error('Expected at least one argument: <output-file>');
	process.exit(1);
}
const outfile = process.argv[2]
console.info(`Writing to: ${outfile}`)
writeFile(outfile)

async function writeFile(outfile: string){
	const out = await createWriteStream(outfile)
	try {
		await out.write("	; FONT TABLES\n")
		await out.write("	; AUTOGENERATED\n\n")
		await out.write("	PADTO $0700\n")
		await writeFontTo(out, glyphs)
	}finally {
		await out.close()
	}	
}

async function writeFontTo(out: WriteStream, font: Record<number, Glyph>){
	let min = 255, max = 0
	for (let c = 0; c < 256; c++) {
		if (font[c]) {
			min = Math.min(c, min)
			max = Math.max(c, max)
		}
	}
	if (min > max) throw "No glyphs found in the font!"
	const count = max - min + 1

	const encoded: EncodedGlyph[] = []
	for (let c = min; c <= max; c++){
		encoded.push(encodedChar(c, font[c]))
	}

	await out.write("FONT_LOOKUP:\n")
	await out.write(`	DB	${hex(min)}	; First glyph codepoint\n`)
	await out.write(`	DB	${hex(count)}	; Glyph count\n`)
	const tableSize = 1 + 1 + 2 * count
	let offset = 0
	let minDelta = 0, maxDelta = 0, i = 0
	for (let enc of encoded) {
		const c = enc.codepoint
		const delta = offset - (i * 6)
		minDelta = Math.min(delta, minDelta)
		maxDelta = Math.max(delta, maxDelta)
		await out.write(`	DW	(FONT_DATA + ${offset})	; character ${c} (${hex(c)}  ‘${Charset[c]}’)   delta ${delta}\n`)
		offset += enc.bytes.length
		i ++
	}
	await out.write(`	; delta from 6* = [${minDelta}..${maxDelta}]\n`)
	await out.write("\n")
	await out.write("FONT_DATA:\n")
	for (let enc of encoded) {
		const c = enc.codepoint
		const bytes = enc.bytes
		await out.write(`	; character ${c} (${hex(c)}  ‘${Charset[c]}’)\n`)
		await out.write(`	DB	${hex(bytes[0])}`)
		for (let i = 1; i < bytes.length; i++) {
			await out.write(`, ${hex(bytes[i])}`)
		}
		await out.write('\n\n')
	}
}

interface EncodedGlyph {
	codepoint: number,
	bytes: number[]
}

function encodedChar(codepoint: number, glyph: Glyph): EncodedGlyph {
	const raw = glyph.bytes
	const encoded: number[] = []
	const nWidth = glyph.width == 'h' ? 1 : glyph.width == 'n' ? 2 : 3

	let firstPixelLine = 8, lastPixelLine = 0
	for (let i = 0; i < 8; i++) {
		const hasPixels = raw[i * 2 + 0] != 0 || raw[i * 2 + 1] != 0
		if (hasPixels) {
			firstPixelLine = Math.min(i, firstPixelLine)
			lastPixelLine = Math.max(i, lastPixelLine)
		}
	}

	const leading = Math.min(Math.max(firstPixelLine, 0), 7)
	const height = Math.min(Math.max(lastPixelLine - firstPixelLine + 1, 0), 7)
	const charInfo = (nWidth << 6) | (leading << 3) | (height << 0)
	encoded.push(charInfo)
	switch (nWidth) {
		case 1:
		case 2:
			const mask = nWidth == 1 ? 0xf0 : 0xff
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix] & mask)
			}
			break;
		case 3:
			for(let r = 0; r < height; r++) {
				const ix = (r + leading) * 2
				encoded.push(raw[ix + 0] & 0xff)
				encoded.push(raw[ix + 1] & 0xf0)
			}
			break;
	}

	return { codepoint, bytes: encoded }
}

function hex(n: number): string {
	return '$' + n.toString(16)
}