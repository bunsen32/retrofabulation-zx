
TEXT_BUFFER	EQU $5C00
LINE_OFFSET_STACK	EQU $5D00
TOKEN_BUFFER	EQU $5D10


	; Read-Execute-Print Loop
POP_AND_REPL:
	pop bc	; Pop off a return address
REPL:
.cls
	ld a,7
	out ($fe),a	; Set border to white
	ld hl,$5800
	ld (hl),0b00111111	; White ink; white paper
	ld de,$5801
	ld bc,768
	ldir 	; Clear screen to all white (16123 t-states)
.init_buffer:
	ld hl,$0000
	ld (G.CAPS_ICON_XY),hl
	ld hl,$0004
	ld (G.MODE_ICON_XY),hl
	ld de,TEXT_BUFFER
	ld bc,0	; prior-chars := 0; subsequent-chars := 0
	ld a,b
	exx
	ld de,LINE_OFFSET_STACK
	ld (de),a
	ld b,$ff	; Max length
	ld c,1	; Current line number
	ld hl,$0300	; First line start coords
	push hl
	exx
	pop hl
	ld (G.CURSOR_XY), hl

	; Clear first character cell so that flashing cursor is visible:
	push bc
	push de
	push hl
	ld de,TWO_SPACES
	ld b,1
	ld a,0b01111000	; black ink, white paper
	call RENDER_TEXT
	pop hl
	pop de
	pop bc

	push hl
	jr CODE_EDITOR.check_key	; We might have come in here with a keypress, so check.

	; Buffer: [xxxxxx|xxxx-----]
	; A: scratch register
	; HL: screen position of cursor (row,half-cell)
	; DE: buffer position of cursor (byte pointer)
	; B : characters prior to cursor
	; C : characters after cursor
	; B': remaining space in buffer (characters)
	; C': Current line number (1-based)
	; HL': screen position of column-zero (row,half-cell)
	; DE': buffer position of column-zero (we push lines on, and pop them off)

	; AF': Carry' = buffer-dirty?
CODE_EDITOR:	
.frame_loop:	halt 	; Wait for some potential keyboard input.
	push hl
	call CURSOR_ANIM_FRAME
	call CAPS_SHIFT_ANIM
.check_key:	ld hl,G.KEY_CHAR
	ld a,(hl)
	ld (hl),0	; So we can detect if a key is pressed while we’re doing other things.
	pop hl

	or a
	jr z,.do_other_stuff
	call LINE_EDIT	; Returns with ‘screen-editing’ command (or zero).
	or a
	jr z,.do_other_stuff
	push af
	rra	; Examine low bit
	jr c,.no_redraw	; Low bit = 1 => cursor move.
	rra	; Examine next bit (redraw)
	jr nc,.no_redraw
	ex af,af'
	scf	; Set buffer dirty
	ex af,af'
.no_redraw:	pop af
	call nz,SCREEN_EDIT_CMD
	jr .frame_loop

.do_other_stuff:	; No key was pressed, so we can do OTHER things…
	ex af,af'	; Check dirty flag in AF'
	jr nc,.frame_loop

.is_dirty:
	push hl
	push de
	push bc
	exx
	push hl
	push bc
	exx
	ASSERT (TEXT_BUFFER & $ff) == 0
	ld d,TEXT_BUFFER>>8	; Add null-terminator to text:
	ld a,b
	add c	; Find end of text...
	ld e,a
	xor a
	ld (de),a	; ...and add \0
	ld e,a
	ld hl,TOKEN_BUFFER
	call TOKENISE
	ld hl,$0900
	ld de,TOKEN_BUFFER
	ld c,$40
	call RENDER_TOKENISED	; (This will trash our dirty flag in F')
	exx
	pop bc
	pop hl
	exx
	pop bc
	pop de
	pop hl
	or a	; Clear (primary) carry flag
	ex af,af'	; AF' Dirty flag is now clear.
	jr .frame_loop

	; Render stream of tokens as text to the screen. Similar model to RENDER_TEXT (it keeps going
	; until it hits the edge of the screen or the end of the stream). However, token stream is null-terminated
	; rather than having an explicit length. And attributes are determined by the tokens!
	; HL: Coordinates to render at
	; DE: Token stream
	; C: (max) number of columns (half-cells) allowed
RENDER_TOKENISED:
	exx
	push hl
	push de
	ld hl,(G.CODE_PALETTE)
	ex de,hl
	exx
	call .body
	exx
	pop de
	pop hl
	exx
	ret
.body:
.loop:	ld a,(de)
	inc de
	srl a	; Carry := was_previous_space?
	jr nc,.missing_sep_space	; No space between previous token and this one
	push de
	ld de,TWO_SPACES
	ld b,1
	ex af,af'	; Restore previous attributes
	call RENDER_TEXT
	ex af,af'	; Restore token identifer
	pop de
	ld c,a	; Stash token	
.missing_sep_space:
	cp TOK_END_SIMPLE
	jr nc,.long_raw_token
.not_raw_token:		; It’s a ‘simple’ token: reserved word or symbol.
	or a
	ret z	; Return if null.
.simple_token:
	push de
	ld d,TOKENS_TEXT>>8
	ld e,a
	ld a,(de)
	ld e,a
	ld a,(de)
	inc e
	ld b,a
	ld a,0b00111010	; Red ink, white paper
	call RENDER_TEXT
	ex af,af'	; Stash attributes
	pop de
	jr .loop
.long_raw_token:		; Carry = UNSET
	ld b,a	; Stash token
	exx	; Now look up colour
	rra	; Carry := is_single_character?
	and 0b111
	ld l,a
	ld h,0
	add hl,de
	ld a,(hl)	; A := attributes for token
	exx
	rr b	; Test lowest bit of token.
	jr nc,.longlong

.shortlong:	ld b,1
	call RENDER_TEXT
	ex af,af'	; Stash attributes
	jr .loop
.longlong:
	push hl
	ex de,hl
	ld e,(hl)
	inc hl
	ld d,(hl)
	inc hl
	ld b,(hl)
	inc hl
	ex (sp),hl
	call RENDER_TEXT
	ex af,af'	; Stash attributes
	pop de
	jr .loop

CODE_PALETTE:
	db 0b01000010	; Invalid
	db 0b00111001	; String
	db 0b00111010	; Identifier
	db 0b00111011	; Comment
	db 0b00111100	; Real
	db 0b00111101	; Int (decimal)
	db 0b00111110	; Int (hex)
	db 0b00111001	; Int (binary)
	db 0b00111001	; Operator
	db 0b00111001	; Control flow
	db 0b00111001	; Punctuation