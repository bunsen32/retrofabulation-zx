	INCLUDE './tokens.def.z80'

	; DE: text stream
	; HL: token stream
TOKENISE:
	call .next
	ld (hl),0
	inc hl
	ret

.next:	ld a,(de)
	ld c,a
	cp $c0
	jp nc,.invalid_sym	; TODO
	ld b,TOKEN_LOOKUP>>8
	ld a,(bc)
	or a	; Clear carry flag (for start word)
	rra
	jr c,.start_word
.start_symbol:	rra
	jr nc,.simple_symbol
.complex_symbol:	inc de	; Peek next char.
	rra	; Break down next 4 bits
	jr c,.odd
.even:	rra	; Common ones: ", #, -, /
	jr c,.odd_even
.even_even:	rra	; ", #
	jp nc,.quote
	jp .hash
.odd_even:	rra	; -, /
	jp nc,.minus
	jp .slash
.odd:	rra	; Less common: %, <, >, * $, !
	jr c,.odd_odd
.even_odd:	rra	; %, <, >
	jp nc,.percent
.odd_even_odd:	rra	; <, >
	jp nc,.lt
	jp .gt
.odd_odd:	rra	; *, $, !
	jp c,.odd_odd_odd
.even_odd_odd:	rra
	jp nc,.asterisk
	jp .dollar
.odd_odd_odd:	rra
	jp nc,.extra_space
.odd_odd_odd_odd:	rra
	jp nc,.exclam
	ret

.simple_symbol:	or a	; Compare to zero
	jr nz,.inc_token_in_a
	jr .invalid_sym

.start_word:	; Character is alphanumeric (including non-Latin letters), or ‘_’.
	cp TOKEN_LOOKUP.digit>>1
	jp nc,.number	; If starts with a digit, parse number.
	push de	; Start of word.
	ld ixh,c	; Stash first character
	inc de
	ld a,(de)	; Fetch second character
	ld c,a
	ld a,(bc)	; Get type of second character
	cp TOKEN_LOOKUP.in_token
	jr nc,.two_plus

.one_char_ident:	; Identifier 1 character long
	pop af	; Discard start of word.
	ld a,ixh	; Retrieve first char.
	cp '_'
	ld b,TOK_DISCARD
	jr z,.token_in_b
	ld (hl),TOK_RAW_IDENT1
	inc hl
	jr .token_in_a	; Not ‘token’ but the single character

.two_plus:	; Identifier longer than 1 character
	push hl	; Well be storing hash in H and length in L (nice!)
	ld hl,(RESERVEDW_HASH.seed << 8)+1
	ld a,ixh	; Retrieve first char
	add h
	rrca
	xor RESERVEDW_HASH.xor
	ld h,a	; h := hashed first character
	
.word_loop:	inc l	; Increase length
	ld a,h	; Add char to hash
	add c
	rrca
	xor RESERVEDW_HASH.xor
	ld h,a
	inc de
	ld a,(de)
	ld c,a
	ld a,(bc)
	cp TOKEN_LOOKUP.in_token
	jr nc,.word_loop

.word_end_loop:	ld a,l
	cp 9
	jp nc,.long_ident	; Too long; not reserved word.
	add h	; Add str length to hash
	rrca
	xor RESERVEDW_HASH.xor
	and 63
	sub RESERVEDW_HASH.first
	jp c,.long_ident
	add RESERVEDW_HASH & $ff	; Low byte of lookup hash table
	ld c,a
	ld b,RESERVEDW_HASH >> 8	; High byte of lookup hash table
	ld a,(bc)
	or a
	ld b,a
	jp z,.long_ident
	pop hl
	pop af	; Discard pushed start of word.
	jr .token_in_b	; TODO: Hash matches, but is the string the same?!

.extra_space:	; Should not occur, but encode run of spaces.
	; (Only encode one at a time. No point in optimising for bad code.)
	ld (hl),TOK_EXTRASPACE
	inc hl
	jp .next

.invalid_sym:	ld (hl),TOK_INVALID
	inc hl
	jp .invalid_sym	; TODO: Read invalid token up until space/EOL

.inc_token_in_b:	inc de
.token_in_b:	ld (hl),b
	jr .token_in_a_incHL	; [skip 2 bytes]

.inc_token_in_a:	inc de
.token_in_a:	ld (hl),a
.token_in_a_incHL:	inc hl
.token_expect_sep:	ld a,(de)
	cp 32
	jr nz,.not_space
.is_space:	inc de	; Fine. We got a space, which indicates token separator.
	jp .next
.not_space:	or a
	ret z	; Return if end of stream.
	ld (hl),TOK_NOSPACE
	inc hl
	jp .next

	// MODULUS OPERATOR AND BINARY LITERAL
.percent:	ld a,(de)	; (<carry> = 0)
	ld b,TOK_MOD
	rra	; Get rid of low bit (don't care if it’s ‘0’ or ‘1’ for now)
	cp '0'>>1
	jr nz,.token_in_b
	push de	; Capture some binary:
.bin_loop	inc de
	ld a,(de)
	cp '_'
	jr z,.bin_loop
	or a
	rra
	cp '0'>>1
	jr z,.bin_loop
	ld a,TOK_RAW_BININT
	jr .long_token

.slash:	ld a,(de)
	cp '/'
	ld a,TOK_DIV
	jr nz,.token_in_a	; Was not followed by another slash. So plain "/" (divide)
	ld a,TOK_FLOORDIV	; WAS followed by another slash. So "//" (floor div)
	jr .inc_token_in_a

.asterisk:	ld a,(de)
	cp '*'
	ld a,TOK_X_MUL
	jr nz,.token_in_a	; Was not followed by another asterisk. So plain "*" (multiply)
	ld a,TOK_EXP	; WAS followed by another asterisk. So "**" (exponent)
	jr .inc_token_in_a

.lt:	ld a,(de)
	cp '='
	ld b,TOK_X_LE	; ‘<=’: Longhand less-than-or-equal ‘≤’
	jr z,.inc_token_in_b
	cp '>'
	ld b,TOK_X0_NE	; ‘<>’: BASIC-style not-equal operator ‘≠’
	jr z,.inc_token_in_b
	cp '<'
	ld b,TOK_LT	; ‘<<’
	jr nz,.token_in_b	; NOT followed by equals or less-than. So plain "<" (less-than)
	ld a,TOK_BITSL
	jr .inc_token_in_a

.gt:	ld a,(de)
	cp '>'
	ld b,TOK_BITSR
	jr z,.inc_token_in_b
	cp '='
	ld a,TOK_GT
	jr nz,.token_in_a	; Was NOT followed by equals. So plain ">" (less-than)
	ld a,TOK_X_GE	; WAS followed by equals. So ">=" (greater-or-equal ‘≥’)
	jr .inc_token_in_a

.long_ident:	ld a,TOK_RAW_IDENT
	pop hl
.long_token:	; It’s a token composed of several characters. Write it to the stream.
	; A: token byte; DE: point to after token content; <stack>: point to start of content.
	ld (hl),a
	inc hl	; Write token ID to the token stream.
	pop bc	; BC := point to start of content
	ld (hl),c
	inc hl
	ld (hl),b
	inc hl	; Write <start> to the token stream
	push de	; Save the "end of content" pointer (to later restore it)
	ex de,hl
	or a	; Clear carry flag
	sbc hl,bc	; HL := length of token. (Assume H == 0)
	ex de,hl
	ld (hl),e
	inc hl
	pop de	; DE := character pointer
	jr .token_expect_sep

.minus_alt:	cp TOKEN_LOOKUP.digit
	ld a,TOK_X_SUB
	jp c,.token_in_a
	jr .number_dec_de

.minus:	rra	; carry-flag => alt version
	ld a,(de)
	ld c,a
	ld a,(bc)	; Look up category of next char
	jr c,.minus_alt
	cp TOKEN_LOOKUP.digit
	ld a,TOK_SUB
	jp c,.token_in_a
.number_dec_de	dec de	; Must include minus symbol in token
	// fall through to number	

	// INTEGER OR FLOAT LITERAL
.number:	push de	; Capture start position
	ld b,-1	; Count the decimal points
.num_loop_point:	inc b	; Increment decimal points
.num_loop:	inc de
	ld a,(de)
	cp '0'
	jr c,.num_lt0
	cp '9'+1
	jr c,.num_loop
.num_gt9:	cp $b7	; Middle-punct
	jr z,.num_loop_point	; Increment number of decimal points
	cp '_'
	jr z,.num_loop
	and %11011111	; Upper-case it.
	cp 'E'
	jr z,.num_exp
	jr .num_end
.num_lt0:	cp '.'	; Period
	jr z,.num_loop_point	; Increment number of decimal points
.num_end:	ld a,TOK_RAW_REAL
	dec b
	jr z,.long_token	; 1 decimal point: TOK_RAW_REAL
	ld a,TOK_RAW_DECINT
	inc b
	jr z,.long_token	; 0 decimal points: TOK_RAW_DECINT
	ld a,TOK_INVALID	; Otherwise: 2–255 decimal points, which is invalid.
	jr .long_token

.num_exp:	nop	; TODO: Parse exponent!

.dollar:	nop	; TODO: Parse hex!

.quote:	nop	; TODO: Parse string!

.hash:	nop	; TODO: Parse comment!

.exclam:	ld a,(de)	; TODO: Parse '!' (Either '!=' or invalid)
	cp '='
	ld b,TOK_X_NE
	jp z,.inc_token_in_b
	jp .invalid_sym

	INCLUDE './tokens.lookup.z80'
	ALIGN 256
	INCLUDE './tokens.text.z80'
	INCLUDE './tokens.hash.z80'