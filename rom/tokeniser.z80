	INCLUDE './tokens.def.z80'

	; DE: text stream
	; HL: token stream
TOKENISE:
	call .next
	ld (hl),0
	inc hl
	ret

.next:	ld a,(de)
	ld c,a
	cp $c0
	jp nc,.invalid_sym	; TODO
	ld b,TOKEN_LOOKUP>>8
	ld a,(bc)
	or a	; Clear carry flag (for start word)
	rra
	jr c,.start_word
.start_symbol:	rra
	jr nc,.simple_symbol
.complex_symbol:	inc de	; Peek next char.
	rra	; Break down next 4 bits
	jr c,.odd
.even:	rra	; Common ones: ", #, -, /
	jr c,.odd_even
.even_even:	rra	; ", #
	jp nc,.quote
	jp .hash
.odd_even:	rra	; -, /
	jp nc,.minus
	jp .slash
.odd:	rra	; Less common: %, <, >, * $, !
	jr c,.odd_odd
.even_odd:	rra	; %, <, >
	jp nc,.percent
.odd_even_odd:	rra	; <, >
	jp nc,.lt
	jp .gt
.odd_odd:	rra	; *, $, !
	jp c,.odd_odd_odd
.even_odd_odd:	rra
	jp nc,.asterisk
	jp .dollar
.odd_odd_odd:	rra
	jp nc,.extra_space
.odd_odd_odd_odd:	rra
	jp nc,.exclam
	ret

	; SYMBOL
.simple_symbol:	or a	; Compare to zero
	jp nz,.inc_token_in_a
	jr .invalid_sym

	; IDENTIFIER OR RESERVED WORD
.start_word:	; Character is alphanumeric (including non-Latin letters), or ‘_’.
	cp TOKEN_LOOKUP.digit>>1
	jp nc,.number	; If starts with a digit, parse number.
	push de	; Start of word.
	ld ixh,c	; Stash first character
	inc de
	ld a,(de)	; Fetch second character
	ld c,a
	ld a,(bc)	; Get type of second character
	cp TOKEN_LOOKUP.in_token
	jr nc,.two_plus

.one_char_ident:	; Identifier 1 character long
	pop af	; Discard start of word.
	ld a,ixh	; Retrieve first char.
	cp '_'
	ld b,TOK_DISCARD
	jr z,.token_in_b
	ld (hl),TOK_RAW_IDENT1
	inc hl
	jr .token_in_a	; Not ‘token’ but the single character

.two_plus:	; Identifier longer than 1 character
	push hl	; Well be storing hash in H and length in L (nice!)
	ld hl,(RESERVEDW_HASH.seed << 8)+1
	ld a,ixh	; Retrieve first char
	add h
	rrca
	xor RESERVEDW_HASH.xor
	ld h,a	; h := hashed first character
	
.word_loop:	inc l	; Increase length
	ld a,h	; Add char to hash
	add c
	rrca
	xor RESERVEDW_HASH.xor
	ld h,a
	inc de
	ld a,(de)
	ld c,a
	ld a,(bc)
	cp TOKEN_LOOKUP.in_token
	jr nc,.word_loop

.word_end_loop:	ld a,l
	cp 9
	jp nc,.long_ident_pophl	; Too long; not reserved word.
	ld a,h
	and 63
	sub RESERVEDW_HASH.first
	jp c,.long_ident_pophl
	add RESERVEDW_HASH & $ff	; Low byte of lookup hash table
	ld c,a
	ld b,RESERVEDW_HASH >> 8	; High byte of lookup hash table
	ld a,(bc)
	or a
	jp z,.long_ident_pophl
	ld b,l
	ld h,TOKENS_TEXT>>8	; TOKENS_TEXT is within 256-byte page.
	ld l,a
	ld c,a	; Stash copy of r'word token code
	ld l,(hl)	; Jump to r'word characters
	ld a,(hl)	; Fetch r'word length
	cp b	; Same as scanned length?
	jp nz,.long_ident_pophl
	push de	; Stash end of token
	add l	; <length>A + <pointer>L
	ld l,a	; L := last char of r'word
.check_loop:	dec de
	ld a,(de)
	cp (hl)
	jr nz,.no_hash_match
	dec l	; DEC [H]L
	djnz .check_loop
	pop de	; Restore end of token pointer
	pop hl
	pop af	; Discard pushed start of word.
	ld a,c
	jr .token_in_a	; Hash matches, and text matches!
.no_hash_match:	pop de	; Restore end of token pointer
	pop hl
	jr .long_ident

	; SPACE
.extra_space:	; Should not occur, but encode run of spaces.
	; (Only encode one at a time. No point in optimising for bad code.)
	ld (hl),TOK_EXTRASPACE
	inc hl
	jp .next

.invalid_sym:	ld (hl),TOK_INVALID
	inc hl
	jp .invalid_sym	; TODO: Read invalid token up until space/EOL

	; WRITE TOKEN
.inc_token_in_b:	inc de
.token_in_b:	ld (hl),b
	jr .token_in_a_incHL	; [skip 2 bytes]

.inc_token_in_a:	inc de
.token_in_a:	ld (hl),a
.token_in_a_incHL:	inc hl
.token_expect_sep:	ld a,(de)
	cp 32
	jr nz,.not_space
.is_space:	inc de	; Fine. We got a space, which indicates token separator.
	jp .next
.not_space:	or a
	ret z	; Return if end of stream.
	ld (hl),TOK_NOSPACE
	inc hl
	jp .next

	; MODULUS OPERATOR AND BINARY LITERAL
.percent:	ld a,(de)	; (<carry> = 0)
	ld b,TOK_MOD
	rra	; Get rid of low bit (don't care if it’s ‘0’ or ‘1’ for now)
	cp '0'>>1
	jr nz,.token_in_b
	push de	; Capture some binary:
.bin_loop	inc de
	ld a,(de)
	cp '_'
	jr z,.bin_loop
	or a
	rra
	cp '0'>>1
	jr z,.bin_loop
	ld a,TOK_RAW_BININT
	jr .long_token

	; DIVIDE AND FLOOR-DIVISION
.slash:	ld a,(de)
	cp '/'
	ld a,TOK_DIV
	jr nz,.token_in_a	; Was not followed by another slash. So plain "/" (divide)
	ld a,TOK_FLOORDIV	; WAS followed by another slash. So "//" (floor div)
	jr .inc_token_in_a

	; MULTIPLY OR EXPONENT
.asterisk:	ld a,(de)
	cp '*'
	ld a,TOK_X_MUL
	jr nz,.token_in_a	; Was not followed by another asterisk. So plain "*" (multiply)
	ld a,TOK_EXP	; WAS followed by another asterisk. So "**" (exponent)
	jr .inc_token_in_a

	; LESS-THAN (AND <=, <>, <<)
.lt:	ld a,(de)
	cp '='
	ld b,TOK_X_LE	; ‘<=’: Longhand less-than-or-equal ‘≤’
	jr z,.inc_token_in_b
	cp '>'
	ld b,TOK_X0_NE	; ‘<>’: BASIC-style not-equal operator ‘≠’
	jr z,.inc_token_in_b
	cp '<'
	ld b,TOK_LT	; ‘<<’
	jr nz,.token_in_b	; NOT followed by equals or less-than. So plain "<" (less-than)
	ld a,TOK_BITSL
	jr .inc_token_in_a

	; GREATER-THAN (AND >=, >>)
.gt:	ld a,(de)
	cp '>'
	ld b,TOK_BITSR
	jr z,.inc_token_in_b
	cp '='
	ld a,TOK_GT
	jr nz,.token_in_a	; Was NOT followed by equals. So plain ">" (less-than)
	ld a,TOK_X_GE	; WAS followed by equals. So ">=" (greater-or-equal ‘≥’)
	jr .inc_token_in_a

	; WRITE ‘LONG’ TOKENS
.long_ident_pophl:	pop hl
.long_ident:	ld a,TOK_RAW_IDENT
.long_token:	; It’s a token composed of several characters. Write it to the stream.
	; A: token byte; DE: point to after token content; <stack>: point to start of content.
	ld (hl),a
	inc hl	; Write token ID to the token stream.
	pop bc	; BC := point to start of content
	ld (hl),c
	inc hl
	ld (hl),b
	inc hl	; Write <start> to the token stream
	push de	; Save the "end of content" pointer (to later restore it)
	ex de,hl
	cp TOK_RAW_DONT_EXCLUDE_LAST_CHAR	; Set carry flag to exlcude last character!
	sbc hl,bc	; HL := length of token. (Assume H == 0)
	ex de,hl
	ld (hl),e
	inc hl
	pop de	; DE := character pointer
	jr .token_expect_sep

	; MINUS SIGN (AS HYPHEN)
.minus_alt:	cp TOKEN_LOOKUP.digit
	ld a,TOK_X_SUB
	jp c,.token_in_a
	jr .number_dec_de

	; MINUS SIGN (AS EN-DASH)
.minus:	rra	; carry-flag => alt version
	ld a,(de)
	ld c,a
	ld a,(bc)	; Look up category of next char
	jr c,.minus_alt
	cp TOKEN_LOOKUP.digit
	ld a,TOK_SUB
	jp c,.token_in_a
.number_dec_de	dec de	; Must include minus symbol in token
	; fall through to number	

	; INTEGER OR FLOAT LITERAL
.number:	push de	; Capture start position
	ld b,0	; Count the decimal points
.num_loop:	inc de
	ld a,(de)
	cp '0'
	jr c,.not_digit
	cp '9'+1
	jr c,.num_loop
.num_gt9:	cp $b7	; Middle-punct
	jr z,.num_decimal_point	; Increment number of decimal points
	cp '_'
	jr z,.num_loop
.not_digit:	cp '.'	; Period
	jr z,.num_decimal_point	; Increment number of decimal points
	and %11011111	; Upper-case it.
	cp 'E'
	jr z,.num_exp
	; otherwise, end loop:
.num_end:	ld a,TOK_RAW_DECINT
	djnz .long_token	; 0 decimal points: TOK_RAW_DECINT
.num_is_real:	ld a,TOK_RAW_REAL
	jr .long_token	; 1 decimal point: TOK_RAW_REAL
.num_decimal_point:	dec b
	jr z,.num_is_real	; If already encountered a point, skip to end.
	inc b	; B := 0
	inc b	; B := 1
	jr .num_loop

.num_exp:	ex de,hl	; Scan real number exponent:
	ld b,TOKEN_LOOKUP>>8	; Use HL for characters, and BC for lookup.
	inc hl
	ld c,(hl)	; Next char
	ld a,(bc)	; Next char classification.
	cp TOKEN_LOOKUP.digit
	jr z,.num_exp_loop
	cp TOK_ADD<<2	; Was plus?
	jr z,.num_exp_1st_digit	; Now look for digit
	and ~(TOKEN_LOOKUP.MINUS ^ TOKEN_LOOKUP.MINUS_ALT)
	cp TOKEN_LOOKUP.MINUS
	ld a,TOK_INVALID
	jr nz,.num_exp_end	; Wasn’t a minus (nor plus, nor digit)
.num_exp_1st_digit:	inc hl	; Expect a digit now
	ld c,(hl)	; Next char
	ld a,(bc)	; Next char classification.
	cp TOKEN_LOOKUP.digit
	ld a,TOK_INVALID
	jr nz,.num_exp_end	; Wasn’t a digit :(
	; Now just loop for digits til end:
.num_exp_loop:	inc hl
	ld c,(hl)	; Next char
	ld a,(bc)	; Next char classification.
	cp TOKEN_LOOKUP.digit
	jr z,.num_exp_loop
	ld a,TOK_RAW_REAL
.num_exp_end:	ex de,hl
	jp .long_token

	; HEX LITERAL
.dollar:	ld a,(de)	; Look for hex literal…
	ld c,a
	ld a,(bc)
	cp TOKEN_LOOKUP.hex_digit
	jp c,.invalid_sym
	push de	; Capture some hex:
.hex_loop	inc de
	ld a,(de)
	cp '_'
	jr z,.hex_loop
	ld c,a
	ld a,(bc)
	cp TOKEN_LOOKUP.hex_digit
	jr nc,.hex_loop
	ld a,TOK_RAW_HEXINT
	jp .long_token

	; OPEN-QUOTE (FOR STRING)
.quote:	push de	; Exclude the opening quote in the capture
.string_loop:	ld a,(de)
	inc de
	cp '"'
	jr z,.string_end
	cp $94	; Double-quote close
	jr z,.string_end
	or a	; Check for end of line
	jr nz,.string_loop
.string_unterminated:	pop bc
	dec bc	; INclude opening quote :/
	push bc
	dec de	; Reverse back over \0 terminator.
	ld a,TOK_INVALID
	jp .long_token	; [or skip next 2 bytes]
.string_end:	ld a,TOK_RAW_STRING
	jp .long_token

	; COMMENT
.hash:	push de
.comment_loop:	ld a,(de)	; Tokenise comment!
	inc de
	or a
	jr nz,.comment_loop
	dec de
	ld a,TOK_RAW_COMMENT
	jp .long_token

	; NOT-EQUALS ("!=" syntax)
.exclam:	ld a,(de)	; Parse '!' (Either '!=' or (TODO) invalid)
	cp '='
	ld b,TOK_X_NE
	jp z,.inc_token_in_b
	jp .invalid_sym

	INCLUDE './tokens.lookup.z80'
	ALIGN 256
	INCLUDE './tokens.text.z80'
	INCLUDE './tokens.hash.z80'