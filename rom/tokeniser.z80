TOK_END	EQU 0
TOK_NONE	EQU 0

; Operators:
TOK_EQ	EQU 1	; =
TOK_NE	EQU 2	; ≠
TOK_LT	EQU 3	; <
TOK_LE	EQU 4	; ≤
TOK_GT	EQU 5	; >
TOK_GE	EQU 6	; ≥
TOK_ADD	EQU 7	; +
TOK_SUB	EQU 8	; –
TOK_MUL	EQU 9	; ×
TOK_DIV	EQU 10	; /
TOK_FLOORDIV	EQU 11	; //
TOK_MOD	EQU 12	; %
TOK_EXP	EQU 13	; **
TOK_BITAND	EQU 14	; &
TOK_BITOR	EQU 15	; |
TOK_BITINV	EQU 16	; ~ [unary operator]
TOK_BITSL	EQU 17	; <<
TOK_BITSR	EQU 18	; >>
TOK_BITXOR	EQU 19	; ^

TOK_LOGOR	EQU 20	; 'or'
TOK_LOGAND	EQU 21	; 'and'
TOK_LOGNOT	EQU 22	; 'not' [unary operator]

; These tokens are alternate versions of operators. Can usually subtract 24 to get to canonical:
TOK_X0_NE	EQU 24	; <>	(Canonical glyph is ‘≠’)
TOK_X_NE	EQU 24+TOK_NE	; !=	(Canonical glyph is ‘≠’)
TOK_X_LE	EQU 24+TOK_LE	; <=	(Canonical glyph is ‘≤’)
TOK_X_GE	EQU 24+TOK_GE	; >=	(Canonical glyph is ‘≥’)
TOK_X_SUB	EQU 24+TOK_SUB	; -	(Canonical glyph is n-dash for minus, not hyphen)
TOK_X_MUL	EQU 24+TOK_MUL	; *	(Canonical glyph is cross-multiply symbol, not asterisk)

TOK_SEMICOLON	EQU 36	; ;
TOK_COLON	EQU 37	; :
TOK_ASSIGN	EQU 38	; :=
TOK_COMMA	EQU 39	; ,
TOK_ARROPEN	EQU 40	; [
TOK_ARRCLOSE	EQU 41	; ]
TOK_PARENOPEN	EQU 42	; (
TOK_PARENCLOSE	EQU 43	; )
TOK_DISCARD	EQU 44	; _
TOK_DOT	EQU 45	; .

TOK_AND	EQU 46	; and
TOK_AS	EQU 47	; as
TOK_BREAK	EQU 48	; break
TOK_CONTINUE	EQU 49	; continue
TOK_DEF	EQU 50	; def
TOK_ELIF	EQU 51	; elif
TOK_ELSE	EQU 52	; else
TOK_FOR	EQU 53	; for
TOK_IF	EQU 54	; if
TOK_IMPORT	EQU 55	; import
TOK_IN	EQU 56	; in
TOK_LET	EQU 57	; let
TOK_LOOP	EQU 58	; loop
TOK_NOT	EQU 59	; not
TOK_OR	EQU 60	; or
TOK_PASS	EQU 61	; pass
TOK_X_PI	EQU 62	; ‘pi’	(Canonical is ‘π’)
TOK_RETURN	EQU 63	; return
TOK_WHILE	EQU 64	; while

TOK_EXTRASPACE	EQU 23	; ' '
TOK_NOSPACE	EQU 65	; Missing space where one is expected.

; Each of these followed by <length> byte and <offset> byte (to text buffer)
TOK_RAW_IDENT	EQU $e0
TOK_RAW_STRING	EQU $e1
TOK_RAW_COMMENT	EQU $e2	; # to end of line
TOK_RAW_INVALID	EQU $e3	; Unrecognised token.
TOK_RAW_REAL	EQU $e4
TOK_RAW_DECINT	EQU $e5
TOK_RAW_HEXINT	EQU $e6
TOK_RAW_BININT	EQU $e7

TOK_PI	EQU $ef	; Pi
TOK_IDENTIFIER	EQU $f0
TOK_STRING	EQU $f1
TOK_COMMENT	EQU $f2	; # to end of line
TOK_INVALID	EQU $ff	; Unrecognised token.

	; DE: text stream
	; HL: token stream
TOKENISE:
	call .next
	ld (hl),0
	inc hl
	ret

.next:	ld a,(de)
	inc de
	ld c,a
	rlca
	jr c,.ascii_80_ff	; $80–$ff

.ascii_00_7f:	rlca
	jr c,.letters_etc	; $40–7f
.ascii_00_3f:	rlca
	jr c,.symbols_digits	; $20–3f
.ascii_00_1f:	or a
	ret z	; $00
	jp .invalid_sym	; $01–1f	TODO! Start with sigil.

.ascii_80_ff:	rlca
	jp c,.invalid_sym	; $c0–ff
.ascii_80_bf:	rlca
	jr c,.ascii_a0_bf
.ascii_80_9f:	rlca
	ld a,c
	jp c,.ascii_9x
	jp .ascii_8x
.ascii_a0_bf	rlca
	ld a,c
	jp c,.ascii_bx
	jp .ascii_ax

.letters_etc:	ld a,c
	and %0011111	; to upper-case
	jr z,.invalid_sym	; '@' or '`' (backtick)
	cp ('Z' & %11111)+1	; One past 'Z' or 'z'
	jr c,.word_like	; Identifier or reserved word.
	
.end_ascii_syms:	ld a,c	; A is in the range $5B..$5F or $7B..$7e
	add %10100000	; Cause a carry if ‘lower-case’ ({, |, }, ~)
	rla	; Low bit is "is lower-case"
	and %1111	; Range: 6..14 ([, {, \, |, ], }, ^, ~, _)
	cp 14
	jr z,.word_like	; It’s an underscore, so test for Identifier (or reserved word or ‘_’)
	add (END_ASCII_SYMS - 6) & $ff
	ld c,a
	ld b,END_ASCII_SYMS>>8
	ld a,(bc)
	or a
	jp nz,.token_in_a
	jp .invalid_sym

.symbols_digits:	ld a,c	; <sp> ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
	sub '%'
	jr c,.early_symbols	; The ‘early symbols’ (<sp> to $) all need special handling; the later ones are looked up in a table.
	cp '0'-'%'
	jr c,.sym_lookup
	cp '9'-'%'+1
	jp c,.number	; 1–9, so parse an (integer or real) number
.sym_lookup2:	sub 10	; Subtract digits from latter symbols (: ; < = > ?)
.sym_lookup:	add (SYM_LOOKUP) & $ff
	ld c,a
	ld b,SYM_LOOKUP>>8
	ld a,(bc)
	or a	; clear carry flag (to rotate into A)
	rra	; a := token (or none), carry := {$ % * /} (may be longer token)
	jr nc,.token_in_a	; Low bit was clear: it’s a (valid) single-character symbolic token.
	rrca	; Okay low bit was set: invalid OR potentially prefix of multichar sym
	jr c,.invalid_sym	; Next low bit set: invalid token!

	; Now potentially prefix of multisymbol token:
.sym_multichar:	ld c,a	; It might be a compound thing, so see if followed by space or null:
	ld a,(de)	; Peek next character
	cp 33	; Is peeked-next-char in range 0–32? If so, it’s a single char token.
	ld b,a	; b := peeked next character
	ld a,c	; a := starting token
	jr c,.token_in_a

.tok_has_more:	; It’s one of ‘%…’ (binary literal?), ‘*…’ (exponent?), ‘/…’ (floor div?), ‘<…’ (<= or <> or <<?) or ‘>…’ (>= or >>?)
	; A =  % ($0C--1100)  * ($21--0001)  / ($0A--1010)  < ($03--0011)  > ($05--0101)  …unique in low 3 bits…
	rra
	jr c,.sym_odd
.sym_even:	rra	; {% /}
	jp c,.slash
	jr .percent
.sym_odd:	rra	; {* < >}
	jp c,.lt
.even_odd:	rra	; {* >}
	jp c,.gt
	jp .asterisk

.early_symbols:	; <sp>($fb) !($fc) "($fd) #($fe) $($ff)  All to be treated specially. (We already subtracted $25 from ASCII values!)
	rra
	jr c,.odd	; Optimise for *_evens, since that includes # and excludes (spurious) <sp>
.even:	rra
	jp c,.hash	; Ends with x10: #($fe)
	jp .exclam	; Ends with x00: !($fc)

.odd:	rra
	jp nc,.quote	; Ends with x01: "($fd)
.odd_odd:	rra
	jp c,.dollar	; Ends with 111: $($ff)
		; Else ends with 011: <sp>($fb)

.extra_space:	; Should not occur, but encode run of spaces.
	; (Only encode one at a time. No point in optimising for bad code.)
	ld (hl),TOK_EXTRASPACE
	inc hl
	jp .next

.underscore:	ld a,(de)	; TODO: Currently fails test when underscore followed by non-space/non-null
	cp 32+1
	ld a,TOK_DISCARD
	jr c,.token_in_a
	nop	; TODO: Parse identifier (fall through to .startw_alpha?)

	; Parse a token that starts with an alphabetic character
.word_like:	dec de
	push de	; Mark the start. If it’s a reserved word, we pop this later.
	inc de
	ld a,(de)
	

.invalid_sym:	ld (hl),TOK_INVALID
	inc hl
	jp .invalid_sym	; TODO: Read invalid token up until space/EOL

.ascii_9x:	cp $93	; TODO: Identify π “ – (plus invalid)
	jp z,.string
	cp $96
	ld b,TOK_SUB
	jr z,.token_in_b
	cp $90
	ld b,TOK_PI
	jr z,.token_in_b
	jr .invalid_sym

.ascii_8x:	cp $81	; TODO: Identify ≠ × (plus invalid)
	ld b,TOK_NE
	jr z,.token_in_b
	cp $83
	ld b,TOK_MUL
	jr z,.token_in_b
	; Just fall through for invalid tokens.

.ascii_ax:	cp $a8	; TODO: Identify ≤ (plus invalid)
	ld b,TOK_LE
	jr z,.token_in_b
	; Just fall through for invalid tokens.

.ascii_bx:	cp $b8	; TODO: Identify ≥ (plus invalid — maybe ∞)
	ld b,TOK_GE
	jr z,.token_in_b
	jr .invalid_sym

.inc_token_in_b:	inc de
.token_in_b:	ld (hl),b
	jr .token_in_a_incHL	; [skip 2 bytes]

.inc_token_in_a:	inc de
.token_in_a:	ld (hl),a
.token_in_a_incHL:	inc hl
.token_expect_sep:	ld a,(de)
	cp 32
	jr nz,.not_space
.is_space:	inc de	; Fine. We got a space, which indicates token separator.
	jp .next
.not_space:	or a
	ret z	; Return if end of stream.
	ld (hl),TOK_NOSPACE
	inc hl
	jp .next

	// MODULUS OPERATOR AND BINARY LITERAL
.percent:	ld a,b	; (<carry> = 0)
	ld b,TOK_MOD
	rra	; Get rid of low bit (don't care if it’s ‘0’ or ‘1’ for now)
	cp '0'>>1
	jr nz,.token_in_b
	push de	; Capture some binary:
.bin_loop	inc de
	ld a,(de)
	cp '_'
	jr z,.bin_loop
	or a
	rra
	cp '0'>>1
	jr z,.bin_loop
	ld a,TOK_RAW_BININT
	jr .long_token

.slash:	ld a,b
	cp '/'
	ld a,TOK_DIV
	jr nz,.token_in_a	; Was not followed by another slash. So plain "/" (divide)
	ld a,TOK_FLOORDIV	; WAS followed by another slash. So "//" (floor div)
	jr .inc_token_in_a

.asterisk:	ld a,b
	cp '*'
	ld a,TOK_X_MUL
	jr nz,.token_in_a	; Was not followed by another asterisk. So plain "*" (multiply)
	ld a,TOK_EXP	; WAS followed by another asterisk. So "**" (exponent)
	jr .inc_token_in_a

.lt:	ld a,b
	cp '='
	ld b,TOK_LE	; ‘<=’: Longhand less-than-or-equal ‘≤’
	jr z,.inc_token_in_b
	cp '>'
	ld b,TOK_X0_NE	; ‘<>’: BASIC-style not-equal operator ‘≠’
	jr z,.inc_token_in_b
	cp '<'
	ld b,TOK_LT	; ‘<<’
	jr nz,.token_in_b	; NOT followed by equals or less-than. So plain "<" (less-than)
	ld a,TOK_BITSL
	jr .inc_token_in_a

.gt:	ld a,b
	cp '>'
	ld b,TOK_BITSR
	jr z,.inc_token_in_b
	cp '='
	ld a,TOK_GT
	jr nz,.token_in_a	; Was NOT followed by equals. So plain ">" (less-than)
	ld a,TOK_GE	; WAS followed by equals. So ">=" (greater-or-equal ‘≥’)
	jr .inc_token_in_a

.long_token:	; It’s a token composed of several characters. Write it to the stream.
	; A: token byte; DE: point to after token content; <stack>: point to start of content.
	ld (hl),a
	inc hl	; Write token ID to the token stream.
	pop bc	; BC := point to start of content
	ld (hl),c
	inc hl
	ld (hl),b
	inc hl	; Write <start> to the token stream
	push de	; Save the "end of content" pointer (to later restore it)
	ex de,hl
	or a	; Clear carry flag
	sbc hl,bc	; HL := length of token. (Assume H == 0)
	ex de,hl
	ld (hl),e
	inc hl
	pop de	; DE := character pointer
	jr .token_expect_sep

	// INTEGER OR FLOAT LITERAL
.number:	dec de
	push de	; Capture start position
	ld b,-1	; Count the decimal points
.num_loop_point:	inc b	; Increment decimal points
.num_loop:	inc de
	ld a,(de)
	cp '0'
	jr c,.num_lt0
	cp '9'+1
	jr c,.num_loop
.num_gt9:	cp $b7	; Middle-punct
	jr z,.num_loop_point	; Increment number of decimal points
	cp '_'
	jr z,.num_loop
	and %11011111	; Upper-case it.
	cp 'E'
	jr z,.num_exp
	jr .num_end
.num_lt0:	cp '.'	; Period
	jr z,.num_loop_point	; Increment number of decimal points
.num_end:	ld a,TOK_RAW_REAL
	dec b
	jr z,.long_token	; 1 decimal point: TOK_RAW_REAL
	ld a,TOK_RAW_DECINT
	inc b
	jr z,.long_token	; 0 decimal points: TOK_RAW_DECINT
	ld a,TOK_INVALID	; Otherwise: 2–255 decimal points, which is invalid.
	jr .long_token

.num_exp:	nop	; TODO: Parse exponent!

.dollar:	nop	; TODO: Parse hex!

.quote:	nop	; TODO: Parse string!

.hash:	nop	; TODO: Parse comment!

.exclam:	ld a,(de)	; TODO: Parse '!' (Either '!=' or invalid)
	cp '='
	ld b,TOK_X_NE
	jp z,.inc_token_in_b
	jp .invalid_sym

.string:	nop	; TODO: Parse string!


	ALIGN 256
END_ASCII_SYMS:
	SAME_PAGE .end
	db TOK_ARROPEN	; $5b  [
	db TOK_NONE	; $7b  { 
	db TOK_NONE	; $5c  \
	db TOK_BITOR	; $7c  |
	db TOK_ARRCLOSE	; $5d  ]
	db TOK_NONE	; $7d  }
	db TOK_BITXOR	; $5e  ^
	db TOK_BITINV	; $7e  ~
.end
SYM_LOOKUP:
	SAME_PAGE .end
	db (TOK_MOD<<2)+%01	; $25  %  Modulus, or start of binary literal
	db (TOK_BITAND<<1)+0	; $26  &
	db ("'"<<2)+%11	; $27  '  <INVALID>
	db (TOK_PARENOPEN<<1)+0	; $28  (
	db (TOK_PARENCLOSE<<1)+0	; $29  )
	db (TOK_X_MUL<<2)+$01	; $2A  *  Multiply, or start of exponent
	db (TOK_ADD<<1)+0	; $2B  +
	db (TOK_COMMA<<1)+0	; $2C  ,
	db (TOK_X_SUB<<1)+0	; $2D  -
	db (TOK_DOT<<1)+0	; $2E  .
	db (TOK_DIV<<2)+%01	; $2F  /  Divide, or start of floor-div
	db (TOK_COLON<<1)+0	; $3a  :
	db (TOK_SEMICOLON<<1)+0	; $3b  ;
	db (TOK_LT<<2)+%01	; $3c  <  Less-than, or start of "<=" or "<>"
	db (TOK_EQ<<1)+0	; $3d  =
	db (TOK_GT<<2)+%01	; $3e  >  Greater-than, or start of ">="
	db ('?'<<2)+%11	; $3f  ?  <INVALID>
.end
