TOK_END	EQU 0
TOK_NONE	EQU 0

; Operators:
TOK_EQ	EQU 1	; =
TOK_NE	EQU 2	; ≠
TOK_LT	EQU 3	; <
TOK_LE	EQU 4	; ≤
TOK_GT	EQU 5	; >
TOK_GE	EQU 6	; ≥
TOK_ADD	EQU 7	; +
TOK_SUB	EQU 8	; –
TOK_MUL	EQU 9	; ×
TOK_DIV	EQU 10	; /
TOK_FLOORDIV	EQU 11	; //
TOK_MOD	EQU 12	; %
TOK_EXP	EQU 13	; **
TOK_BITAND	EQU 14	; &
TOK_BITOR	EQU 15	; |
TOK_BITINV	EQU 16	; ~ [unary operator]
TOK_BITSL	EQU 17	; <<
TOK_BITSR	EQU 18	; >>
TOK_BITXOR	EQU 19	; ^

TOK_LOGOR	EQU 20	; 'or'
TOK_LOGAND	EQU 21	; 'and'
TOK_LOGNOT	EQU 22	; 'not' [unary operator]

; These tokens are alternate versions of operators. Can usually subtract 24 to get to canonical:
TOK_X0_NE	EQU 24	; <>
TOK_X_NE	EQU 24+TOK_NE	; !=
TOK_X_LE	EQU 24+TOK_LE	; <=
TOK_X_GE	EQU 24+TOK_GE	; >=
TOK_X_SUB	EQU 24+TOK_SUB	; -	(Canonical glyph is n-dash for minus, not hyphen)
TOK_X_MUL	EQU 24+TOK_MUL	; *	(Canonical glyph is cross-multiply symbol, not asterisk)

TOK_SEMICOLON	EQU 36	; ;
TOK_COLON	EQU 37	; :
TOK_ASSIGN	EQU 38	; :=
TOK_COMMA	EQU 39	; ,
TOK_ARROPEN	EQU 40	; [
TOK_ARRCLOSE	EQU 41	; ]
TOK_PARENOPEN	EQU 42	; (
TOK_PARENCLOSE	EQU 43	; )
TOK_DISCARD	EQU 44	; _
TOK_DOT	EQU 45	; .

TOK_SPACES	EQU 64	; ' ' x n
TOK_NOSPACE	EQU 65	; Missing space where one is expected.

TOK_PI	EQU $ef	; Pi
TOK_IDENTIFIER	EQU $f0
TOK_STRING	EQU $f1
TOK_COMMENT	EQU $f2	; # to end of line
TOK_INVALID	EQU -1	; Unrecognised token.

	; DE: text stream
	; HL: token stream
TOKENISE:
	call .next
	ld (hl),0
	inc hl
	ret

.next:	ld a,(de)
	inc de
	ld c,a
	rlca
	jr c,.ascii_80_ff	; $80–$ff

.ascii_00_7f:	rlca
	jr c,.letters_etc	; $40–7f
.ascii_00_3f:	rlca
	jr c,.symbols_digits ; $20–3f
.ascii_00_1f:	or a
	ret z	; $00
	jp .invalid_sym	; $01–1f	TODO! Start with sigil.

.ascii_80_ff:	rlca
	jp c,.invalid_sym	; $c0–ff
.ascii_80_bf:	rlca
	jr c,.ascii_a0_bf
.ascii_80_9f:	rlca
	ld a,c
	jp c,.ascii_9x
	jp .ascii_8x
.ascii_a0_bf	rlca
	ld a,c
	jp c,.ascii_bx
	jp .ascii_ax

.letters_etc:	ld a,c
	and %0011111	; to upper-case
	jr z,.invalid_sym	; '@' or '`' (backtick)
	cp 27	; One past 'Z' or 'z'
	jr c,.startw_alpha	 
	
.end_ascii_syms:	ld a,c	; A is in the range $5B..$5F or $7B..$7e
	add %10100000	; Cause a carry if ‘lower-case’ ({, |, }, ~)
	rla	; Low bit is "is lower-case"
	and %1111	; Range: 6..14 ([, {, \, |, ], }, ^, ~, _)
	cp 14
	jr z,.underscore
	add (END_ASCII_SYMS - 6) & $ff
	ld c,a
	ld b,END_ASCII_SYMS>>8
	ld a,(bc)
	or a
	jp nz,.token_in_a
	jp .invalid_sym

.symbols_digits:	ld a,c	; <sp> ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
	sub '%'
	jr c,.early_symbols
	cp '0'-'%'
	jr c,.sym_lookup
.digit:	cp '9'-'%'+1
	jr nc,.sym_lookup2
	nop
	; TODO: starts with digit (=> int or float literal)

.sym_lookup2:	sub 10	; Subtract digits from latter symbols (: ; < = > ?)
.sym_lookup:	add (SYM_LOOKUP) & $ff
	ld c,a
	ld b,SYM_LOOKUP>>8
	ld a,(bc)
	or a	; clear carry flag (to rotate into A)
	rra	; a := token (or none), carry := {$ % * /} (may be longer token)
	jr nc,.token_in_a	; Low bit was clear: it’s a (valid) single-character symbolic token.
	rrca	; Okay low bit was set: invalid OR potentially prefix of multichar sym
	jr c,.invalid_sym	; Next low bit set: invalid token!

	; Now potentially prefix of multisymbol token:
.sym_multichar:	ld c,a	; It might be a compound thing, so see if followed by space or null:
	ld a,(de)	; Peek next character
	cp 33	; Is peeked-next-char in range 0–32? If so, it’s a single char token.
	ld b,a	; b := peeked next character
	ld a,c	; a := starting token
	jr c,.token_in_a

.tok_has_more:	; It’s one of ‘%…’ (binary literal?), ‘*…’ (exponent?), ‘/…’ (floor div?), ‘<…’ (<= or <> or <<?) or ‘>…’ (>= or >>?)
	; A =  % ($0C--1100)  * ($21--0001)  / ($0A--1010)  < ($03--0011)  > ($05--0101)  …unique in low 3 bits…
	rra
	jr c,.sym_odd
.sym_even:	rra	; {% /}
	jp c,.slash
	jr .percent
.sym_odd:	rra	; {* < >}
	jp c,.lt
.even_odd:	rra	; {* >}
	jp c,.gt
	jp .asterisk

.early_symbols:	; <sp>($fb) !($fc) "($fd) #($fe) $($ff)  All to be treated specially. (We already subtracted $25 from ASCII values!)
	rra
	jr c,.odd	; Optimise for *_evens, since that includes # and excludes (spurious) <sp>
.even:	rra
	jp c,.hash	; Ends with x10: #($fe)
	jp .exclam	; Ends with x00: !($fc)

.odd:	rra
	jp nc,.quote	; Ends with x01: "($fd)
.odd_odd:	rra
	jp c,.dollar	; Ends with 111: $($ff)
		; Else ends with 011: <sp>($fb)

.extra_spaces:	; Should not occur, but encode run of spaces. TODO: allow more than one.
	ld (hl),TOK_SPACES
	inc hl
	ld (hl),1
	inc hl
	jp .next

.underscore:	ld a,(de)
	cp 32+1
	ld a,TOK_DISCARD
	jr c,.token_in_a
	nop	; TODO: Parse identifier (fall through to .startw_alpha?)

	; Parse a token that starts with an alphabetic character
.startw_alpha:	nop	; TODO

.invalid_sym:	ld (hl),TOK_INVALID
	inc hl
	nop	; TODO: Read invalid token up until space/EOL

.ascii_8x:	cp $81	; TODO: Identify ≠ × (plus invalid)
	ld b,TOK_NE
	jr z,.token_in_b
	cp $83
	ld b,TOK_MUL
	jr z,.token_in_b
	; Just fall through for invalid tokens.

.ascii_9x:	cp $93	; TODO: Identify π “ – (plus invalid)
	jp z,.string
	cp $96
	ld b,TOK_SUB
	jr z,.token_in_b
	cp $90
	ld b,TOK_PI
	jr z,.token_in_b
	; Just fall through for invalid tokens.

.ascii_ax:	cp $a8	; TODO: Identify ≤ (plus invalid)
	ld b,TOK_LE
	jr z,.token_in_b
	; Just fall through for invalid tokens.

.ascii_bx:	cp $b8	; TODO: Identify ≥ (plus invalid — maybe ∞)
	ld b,TOK_GE
	jr z,.token_in_b
	jr .invalid_sym

.inc_token_in_b:	inc de
.token_in_b:	ld (hl),b
	jr .token_in_a_incHL	; skip 2 bytes

.inc_token_in_a:	inc de
.token_in_a:	ld (hl),a
.token_in_a_incHL:	inc hl
	ld a,(de)
	cp 32
	jr nz,.not_space
.is_space:	inc de	; Fine. We got a space, which indicates token separator.
	jp .next
.not_space:	or a
	ret z	; Return if end of stream.
	ld (hl),TOK_NOSPACE
	inc hl
	jp .next

.percent:	ld a,b
	ld b,TOK_MOD
	sub '0'
	jr c,.token_in_b
	cp 2
	jr nc,.token_in_b
	nop	; TODO: Try to parse some binary!

.slash:	ld a,b
	cp '/'
	ld a,TOK_DIV
	jr nz,.token_in_a	; Was not followed by another slash. So plain "/" (divide)
	ld a,TOK_FLOORDIV	; WAS followed by another slash. So "//" (floor div)
	jr .inc_token_in_a

.asterisk:	ld a,b
	cp '*'
	ld a,TOK_X_MUL
	jr nz,.token_in_a	; Was not followed by another asterisk. So plain "*" (multiply)
	ld a,TOK_EXP	; WAS followed by another asterisk. So "**" (exponent)
	jr .inc_token_in_a

.lt:	ld a,b
	cp '='
	ld b,TOK_LE	; ‘<=’: Longhand less-than-or-equal ‘≤’
	jr z,.inc_token_in_b
	cp '>'
	ld b,TOK_X0_NE	; ‘<>’: BASIC-style not-equal operator ‘≠’
	jr z,.inc_token_in_b
	cp '<'
	ld b,TOK_LT	; ‘<<’
	jr nz,.token_in_b	; NOT followed by equals or less-than. So plain "<" (less-than)
	ld a,TOK_BITSL
	jr .inc_token_in_a

.gt:	ld a,b
	cp '>'
	ld b,TOK_BITSR
	jr z,.inc_token_in_b
	cp '='
	ld a,TOK_GT
	jr nz,.token_in_a	; Was NOT followed by equals. So plain ">" (less-than)
	ld a,TOK_GE	; WAS followed by equals. So ">=" (greater-or-equal ‘≥’)
	jr .inc_token_in_a

.dollar:	nop	; TODO: Parse hex!

.quote:	nop	; TODO: Parse string!

.hash:	nop	; TODO: Parse comment!

.exclam:	ld a,(de)	; TODO: Parse '!' (Either '!=' or invalid)
	cp '='
	ld b,TOK_X_NE
	jr z,.inc_token_in_b
	jp .invalid_sym

.string:	nop	; TODO: Parse string!


	ALIGN 256
END_ASCII_SYMS:
	SAME_PAGE .end
	db TOK_ARROPEN	; $5b  [
	db TOK_NONE	; $7b  { 
	db TOK_NONE	; $5c  \
	db TOK_BITOR	; $7c  |
	db TOK_ARRCLOSE	; $5d  ]
	db TOK_NONE	; $7d  }
	db TOK_BITXOR	; $5e  ^
	db TOK_BITINV	; $7e  ~
.end
SYM_LOOKUP:
	SAME_PAGE .end
	db (TOK_MOD<<2)+%01	; $25  %  Modulus, or start of binary literal
	db (TOK_BITAND<<1)+0	; $26  &
	db ("'"<<2)+%11	; $27  '  <INVALID>
	db (TOK_PARENOPEN<<1)+0	; $28  (
	db (TOK_PARENCLOSE<<1)+0	; $29  )
	db (TOK_X_MUL<<2)+$01	; $2A  *  Multiply, or start of exponent
	db (TOK_ADD<<1)+0	; $2B  +
	db (TOK_COMMA<<1)+0	; $2C  ,
	db (TOK_X_SUB<<1)+0	; $2D  -
	db (TOK_DOT<<1)+0	; $2E  .
	db (TOK_DIV<<2)+%01	; $2F  /  Divide, or start of floor-div
	db (TOK_COLON<<1)+0	; $3a  :
	db (TOK_SEMICOLON<<1)+0	; $3b  ;
	db (TOK_LT<<2)+%01	; $3c  <  Less-than, or start of "<=" or "<>"
	db (TOK_EQ<<1)+0	; $3d  =
	db (TOK_GT<<2)+%01	; $3e  >  Greater-than, or start of ">="
	db ('?'<<2)+%11	; $3f  ?  <INVALID>
.end
