TOK_END	EQU 0
TOK_NONE	EQU 0

; Operators:
TOK_EQ	EQU 1	; =
TOK_NE	EQU 2	; ≠
TOK_LT	EQU 3	; <
TOK_LE	EQU 4	; ≤
TOK_GT	EQU 5	; >
TOK_GE	EQU 6	; ≥
TOK_ADD	EQU 7	; +
TOK_SUB	EQU 8	; –
TOK_MUL	EQU 9	; ×
TOK_DIV	EQU 10	; /
TOK_FLOORDIV	EQU 11	; //
TOK_MOD	EQU 12	; %
TOK_EXP	EQU 13	; **
TOK_BITAND	EQU 14	; &
TOK_BITOR	EQU 15	; |
TOK_BITINV	EQU 16	; ~ [unary operator]
TOK_BITSL	EQU 17	; <<
TOK_BITSR	EQU 18	; >>
TOK_BITXOR	EQU 19	; ^

TOK_LOGOR	EQU 20	; 'or'
TOK_LOGAND	EQU 21	; 'and'
TOK_LOGNOT	EQU 22	; 'not' [unary operator]

; These tokens are alternate versions of operators. Can usually subtract 24 to get to canonical:
TOK_X0_NE	EQU 24	; <>	(Canonical glyph is ‘≠’)
TOK_X_NE	EQU 24+TOK_NE	; !=	(Canonical glyph is ‘≠’)
TOK_X_LE	EQU 24+TOK_LE	; <=	(Canonical glyph is ‘≤’)
TOK_X_GE	EQU 24+TOK_GE	; >=	(Canonical glyph is ‘≥’)
TOK_X_SUB	EQU 24+TOK_SUB	; -	(Canonical glyph is n-dash for minus, not hyphen)
TOK_X_MUL	EQU 24+TOK_MUL	; *	(Canonical glyph is cross-multiply symbol, not asterisk)

TOK_PI	EQU 35	; Pi

TOK_SEMICOLON	EQU 36	; ;
TOK_COLON	EQU 37	; :
TOK_ASSIGN	EQU 38	; :=
TOK_COMMA	EQU 39	; ,
TOK_ARROPEN	EQU 40	; [
TOK_ARRCLOSE	EQU 41	; ]
TOK_PARENOPEN	EQU 42	; (
TOK_PARENCLOSE	EQU 43	; )
TOK_DOT	EQU 44	; .

TOK_DISCARD	EQU 45	; _
TOK_AND	EQU 46	; and
TOK_AS	EQU 47	; as
TOK_BREAK	EQU 48	; break
TOK_CONTINUE	EQU 49	; continue
TOK_DEF	EQU 50	; def
TOK_ELIF	EQU 51	; elif
TOK_ELSE	EQU 52	; else
TOK_FOR	EQU 53	; for
TOK_IF	EQU 54	; if
TOK_IMPORT	EQU 55	; import
TOK_IN	EQU 56	; in
TOK_LET	EQU 57	; let
TOK_LOOP	EQU 58	; loop
TOK_NOT	EQU 59	; not
TOK_OR	EQU 60	; or
TOK_PASS	EQU 61	; pass
TOK_X_PI	EQU 62	; ‘pi’	(Canonical is ‘π’)
TOK_RETURN	EQU 63	; return
TOK_WHILE	EQU 64	; while

TOK_EXTRASPACE	EQU 23	; ' '
TOK_NOSPACE	EQU 65	; Missing space where one is expected.

; Each of these followed by <length> byte and <offset> byte (to text buffer)
TOK_RAW_IDENT	EQU $e0
TOK_RAW_STRING	EQU $e1
TOK_RAW_COMMENT	EQU $e2	; # to end of line
TOK_RAW_INVALID	EQU $e3	; Unrecognised token.
TOK_RAW_REAL	EQU $e4
TOK_RAW_DECINT	EQU $e5
TOK_RAW_HEXINT	EQU $e6
TOK_RAW_BININT	EQU $e7

TOK_IDENTIFIER	EQU $f0
TOK_STRING	EQU $f1
TOK_COMMENT	EQU $f2	; # to end of line
TOK_INVALID	EQU $ff	; Unrecognised token.

	; DE: text stream
	; HL: token stream
TOKENISE:
	call .next
	ld (hl),0
	inc hl
	ret

.next:	ld a,(de)
	ld c,a
	cp $c0
	jr nc,.invalid_sym	; TODO
	ld b,TOKEN_LOOKUP>>8
	ld a,(bc)
	or a	; Clear carry flag (for start word)
	rra
	jr c,.start_word
.start_symbol:	rra
	jr nc,.simple_symbol
.complex_symbol:	inc de	; Peek next char.
	rra	; Break down next 4 bits
	jr c,.odd
.even:	rra	; Common ones: ", #, -, /
	jr c,.odd_even
.even_even:	rra	; ", #
	jp nc,.quote
	jp .hash
.odd_even:	rra	; -, /
	jp nc,.minus
	jp .slash
.odd:	rra	; Less common: %, <, >, * $, !
	jr c,.odd_odd
.even_odd:	rra	; %, <, >
	jp nc,.percent
.odd_even_odd:	rra	; <, >
	jp nc,.lt
	jp .gt
.odd_odd:	rra	; *, $, !
	jp c,.odd_odd_odd
.even_odd_odd:	rra
	jp nc,.asterisk
	jp .dollar
.odd_odd_odd:	rra
	jp nc,.extra_space
.odd_odd_odd_odd:	rra
	jp nc,.exclam
	ret

.simple_symbol:	or a	; Compare to zero
	jr nz,.inc_token_in_a
	jr .invalid_sym

.start_word:	; Character is alphanumeric (including non-Latin alphabet), or ‘_’.
	cp TOKEN_LOOKUP.digit>>1
	jp nc,.number
	push de
.word_loop:	inc de
	ld a,(de)
	ld c,a
	ld a,(bc)
	cp TOKEN_LOOKUP.in_token
	jr nc,.word_loop
	ld a,TOK_RAW_IDENT
	jp .long_token

.extra_space:	; Should not occur, but encode run of spaces.
	; (Only encode one at a time. No point in optimising for bad code.)
	ld (hl),TOK_EXTRASPACE
	inc hl
	jp .next

.invalid_sym:	ld (hl),TOK_INVALID
	inc hl
	jp .invalid_sym	; TODO: Read invalid token up until space/EOL

.inc_token_in_b:	inc de
.token_in_b:	ld (hl),b
	jr .token_in_a_incHL	; [skip 2 bytes]

.inc_token_in_a:	inc de
.token_in_a:	ld (hl),a
.token_in_a_incHL:	inc hl
.token_expect_sep:	ld a,(de)
	cp 32
	jr nz,.not_space
.is_space:	inc de	; Fine. We got a space, which indicates token separator.
	jp .next
.not_space:	or a
	ret z	; Return if end of stream.
	ld (hl),TOK_NOSPACE
	inc hl
	jp .next

	// MODULUS OPERATOR AND BINARY LITERAL
.percent:	ld a,(de)	; (<carry> = 0)
	ld b,TOK_MOD
	rra	; Get rid of low bit (don't care if it’s ‘0’ or ‘1’ for now)
	cp '0'>>1
	jr nz,.token_in_b
	push de	; Capture some binary:
.bin_loop	inc de
	ld a,(de)
	cp '_'
	jr z,.bin_loop
	or a
	rra
	cp '0'>>1
	jr z,.bin_loop
	ld a,TOK_RAW_BININT
	jr .long_token

.slash:	ld a,(de)
	cp '/'
	ld a,TOK_DIV
	jr nz,.token_in_a	; Was not followed by another slash. So plain "/" (divide)
	ld a,TOK_FLOORDIV	; WAS followed by another slash. So "//" (floor div)
	jr .inc_token_in_a

.asterisk:	ld a,(de)
	cp '*'
	ld a,TOK_X_MUL
	jr nz,.token_in_a	; Was not followed by another asterisk. So plain "*" (multiply)
	ld a,TOK_EXP	; WAS followed by another asterisk. So "**" (exponent)
	jr .inc_token_in_a

.lt:	ld a,(de)
	cp '='
	ld b,TOK_X_LE	; ‘<=’: Longhand less-than-or-equal ‘≤’
	jr z,.inc_token_in_b
	cp '>'
	ld b,TOK_X0_NE	; ‘<>’: BASIC-style not-equal operator ‘≠’
	jr z,.inc_token_in_b
	cp '<'
	ld b,TOK_LT	; ‘<<’
	jr nz,.token_in_b	; NOT followed by equals or less-than. So plain "<" (less-than)
	ld a,TOK_BITSL
	jr .inc_token_in_a

.gt:	ld a,(de)
	cp '>'
	ld b,TOK_BITSR
	jr z,.inc_token_in_b
	cp '='
	ld a,TOK_GT
	jr nz,.token_in_a	; Was NOT followed by equals. So plain ">" (less-than)
	ld a,TOK_X_GE	; WAS followed by equals. So ">=" (greater-or-equal ‘≥’)
	jr .inc_token_in_a

.long_token:	; It’s a token composed of several characters. Write it to the stream.
	; A: token byte; DE: point to after token content; <stack>: point to start of content.
	ld (hl),a
	inc hl	; Write token ID to the token stream.
	pop bc	; BC := point to start of content
	ld (hl),c
	inc hl
	ld (hl),b
	inc hl	; Write <start> to the token stream
	push de	; Save the "end of content" pointer (to later restore it)
	ex de,hl
	or a	; Clear carry flag
	sbc hl,bc	; HL := length of token. (Assume H == 0)
	ex de,hl
	ld (hl),e
	inc hl
	pop de	; DE := character pointer
	jr .token_expect_sep

.minus_alt:	cp TOKEN_LOOKUP.digit
	ld a,TOK_X_SUB
	jp c,.token_in_a
	jr .number_dec_de

.minus:	rra	; carry-flag => alt version
	ld a,(de)
	ld c,a
	ld a,(bc)	; Look up category of next char
	jr c,.minus_alt
	cp TOKEN_LOOKUP.digit
	ld a,TOK_SUB
	jp c,.token_in_a
.number_dec_de	dec de	; Must include minus symbol in token
	// fall through to number	

	// INTEGER OR FLOAT LITERAL
.number:	push de	; Capture start position
	ld b,-1	; Count the decimal points
.num_loop_point:	inc b	; Increment decimal points
.num_loop:	inc de
	ld a,(de)
	cp '0'
	jr c,.num_lt0
	cp '9'+1
	jr c,.num_loop
.num_gt9:	cp $b7	; Middle-punct
	jr z,.num_loop_point	; Increment number of decimal points
	cp '_'
	jr z,.num_loop
	and %11011111	; Upper-case it.
	cp 'E'
	jr z,.num_exp
	jr .num_end
.num_lt0:	cp '.'	; Period
	jr z,.num_loop_point	; Increment number of decimal points
.num_end:	ld a,TOK_RAW_REAL
	dec b
	jr z,.long_token	; 1 decimal point: TOK_RAW_REAL
	ld a,TOK_RAW_DECINT
	inc b
	jr z,.long_token	; 0 decimal points: TOK_RAW_DECINT
	ld a,TOK_INVALID	; Otherwise: 2–255 decimal points, which is invalid.
	jr .long_token

.num_exp:	nop	; TODO: Parse exponent!

.dollar:	nop	; TODO: Parse hex!

.quote:	nop	; TODO: Parse string!

.hash:	nop	; TODO: Parse comment!

.exclam:	ld a,(de)	; TODO: Parse '!' (Either '!=' or invalid)
	cp '='
	ld b,TOK_X_NE
	jp z,.inc_token_in_b
	jp .invalid_sym

	INCLUDE './tokeniser.lookup.z80'