	; Keyboard & default interrupt handler
	; Obviously saves and restores any used registers.
	; But also: does not depend upon any particular values in IX, IY or exx registers.
DEFAULT_INTERRUPT_HANDLER:
	push	hl
	push	af
	ld	hl, (CLOCK_TICKS)
	inc	hl
	ld	(CLOCK_TICKS), hl
	ld	a,l
	or	h
	jr	nz, .low_bits_only
	ld	hl, CLOCK_TICKS+2
	inc	(hl)
.low_bits_only:	push	bc
	push	de
	call	KEYBOARD
	pop	de
	pop	bc
	pop	af
	pop	hl
	ei
	ret

KCODE_CAPS	equ	0
KCODE_SYM	equ	15
CHAR_LEFT	equ	$01
CHAR_RIGHT	equ	$02
CHAR_UP	equ	$04
CHAR_DOWN	equ	$03

KEYMAP_SHIFTED_NUMS:
	SAME_PAGE	.end
	db	$08	; 0: DELETE (BACKSPACE)
	db	$0b	; 1: EDIT/ESC
	db	$0e	; 2: CAPS LOCK
	db	$05	; 3: INV VIDEO
	db	$06	; 4: TRUE VIDEO
	db	$01	; 5: LEFT
	db	$03	; 6: DOWN
	db	$04	; 7: UP
	db	$02	; 8: RIGHT
	db	$0f	; 9: GRAPHICS
.end

KEYMAP:
	db	' ', 'a', 'q', '1', '0', 'p', $0d, ' '
	db	'z', 's', 'w', '2', '9', 'o', 'l', ' '
	db	'x', 'd', 'e', '3', '8', 'i', 'k', 'm'
	db	'c', 'f', 'r', '4', '7', 'u', 'j', 'n'
	db	'v', 'g', 't', '5', '6', 'y', 'h', 'b'

KEYMAP_SYM:
	db	' ', '~', $a8, '!', '_', '"', $0a, ' '
	db	':', '|', $81, '@', ')', ';', '=', ' '
	db	$a3, '\', $b8, '#', '(', '`', '+', '.'
	db	'?', '{', '<', '$', "'", ']', '-', ','
	db	'/', '}', '>', '%', '&', '[', '^', '*'


; Interrogate the hardware for the current keyboard state
; Collects state of both shift keys (in A), and 0, 1, or 2 other keys (in D & E)
; Returns:
; B: 000000<sym><caps>
; D: non-shift key code or zero (second key, if any)
; E: non-shift key code or zero (first key)
; HL, C: trashed
KEY_SCAN:
	ld	bc, $fefe
	ld	de, $0000
	ld	l, -8
	push	de	; Push zeros (current shift state) onto stack.
.each_line:
	in	a,(c)
	cpl
	and	$1f
	jr	nz, .line_has_bits
.next_line:	inc	l
	rlc	b
	jr	c, .each_line
.end_success:
	cp	a	; Set zero flag
.too_many_keys:
	pop	bc	; Pop shift state
	ret

.line_has_bits:
	ld	h, a
	ld	a, l
.each_bit:
	add	8	; Key code += 8
	srl	h
	jr	nc, .each_bit
.key_is_down
	or	a	; Does ‘key code’ == KCODE_CAPS (0)?
	jr	z, .caps_shift
	cp	KCODE_SYM	; Does ‘key code’ == KCODE_SYM (15)?
	jr	z, .sym_shift
	inc	d
	dec	d
	jr	nz, .too_many_keys
	ld	d, e
	ld	e, a
	add	8
.maybe_last:
	srl	h
	jr	c,.key_is_down
	jr	nz,.each_bit
	jr	.next_line
.sym_shift:
	pop	af
	add	2	; Set bit 1
	push	af
	ld	a, KCODE_SYM + 8
	jr	.maybe_last
.caps_shift:
	pop	af
	inc	a	; Set bit 0
	push	af
	ld	a, KCODE_CAPS + 8
	jr	.maybe_last


; Scan the keyboard, then turn it into the next keyboard character:
KEYBOARD:
	call	KEY_SCAN
	ret	nz	; Return if too many keys

.after_scan:			; Label here so we can run the decode logic in tests.
	ld	hl, KEY_MODIFIERS
	ld	a,(hl)
	and	0b11111100	; Mask out previous shifts
	or	b 
	ld	b,a
	ld	(hl),b	; KEY_MODIFIERS := <shift flags>
	inc	l	; Points now to ‘KEY_SUPERSEDED’
	
	xor	a
	ld	c, a	; Indicator of ‘no key’
	cp	e
	jr	z,.keyup	; No keys (or only shift keys) pressed.

	cp	d	; Two keys pressed at once?
	jr	nz,.disambiguate
.end_superseded:
	ld	(hl),c	; KEY_SUPERSEDED := <none>
.keypress:			; We’ve removed any ‘superseded’ key. Now deal with press, or repeat:
	inc	l	; Points now to ‘KEY_RPT_CODE’
	ld	a,e
	cp	(hl)	; Is this a repeating key?
	jr	z,.try_repeat
.new_key:
	ld	(hl),a	; KEY_RPT_CODE := <new key code>
	inc	l	; Points now to ‘KEY_RPT_NEXT’
	ld	a,(REPDEL)	; Repeat delay
	ld	(hl),a	; KEY_RPT_NEXT := (REPDEL)
.decode
	ld	d,c	; d := <zero>
	push	hl	; Push address of "KEY_RPT_NEXT"
	ld	hl,KEYMAP
	bit	1,b
	jr	z,.look_up
	ld	hl,KEYMAP_SYM	; Override with the symbol shift lookup.
.look_up:	add	hl,de
	ld	a,(hl)

	cp	'A'
	jr	c, .not_alpha
.alpha:
	bit	0,b
	jr	nz, .capitalise
	bit	7,b
	jr	z, .save_char
.capitalise:	sub	'a'-'A'
	jr	.save_char	
.not_alpha:
	bit	0,b
	jr	z, .no_CAPS_shift
	cp	'0'
	jr	c,.no_CAPS_shift	; Skip this bit if SPACE or ENTER
	ld	h, (KEYMAP_SHIFTED_NUMS - '0') >> 8
	add	(KEYMAP_SHIFTED_NUMS - '0') & $ff
	ld	l, a
	ld	a, (hl)
.no_CAPS_shift
.save_char:	pop	hl
.write_final_key:	inc	l	; Points now to ‘KEY_CHAR’
	ld	(hl),a	; KEY_CHAR
	ret

.try_repeat:
	inc	l	; Points now to ‘KEY_RPT_NEXT’
	dec	(hl)	; Count down the frames to next repetition
	jr	nz,.repeat_wait	; Not reached zero count yet, so mark character as <none>
	ld	a,(REPPER)
	ld	(hl),a	; KEY_RPT_NEXT := (REPPER)
	jr	.decode
.keyup:
	ld	(hl),c	; KEY_SUPERSEDED := 0
	inc	l	; Points now to ‘KEY_RPT_CODE’
	ld	(hl),c	; KEY_RPT_CODE := 0
	inc	l	; Points now to ‘KEY_RPT_NEXT’
.repeat_wait	inc	l	; Points now to ‘KEY_CHAR’
	ld	(hl),c	; KEY_CHAR := 0
	ret

.disambiguate:	; Two keys are pressed at once… so deal with that!
	ld	a,(hl)	; a := <The key to ignore, if two pressed at once>
	or	a
	jr	nz,.has_superseded
.decide_superseded:
	inc	l	; hl := KEY_RPT_CODE
	ld	a,(hl)	; a := (KEY_RPT_CODE)
	dec	l
	ld	(hl),a	; KEY_SUPERSEDED := KEY_RPT_CODE
.has_superseded:
	cp	d
	jr	z, .keypress	; Supersede the secondary key?
			; We favour the primary one anyway, so there’s no need to explicitly ignore the second one.
	cp	e
	jr	nz, .end_superseded	; Doesn’t match either primary or secondary? Clear superseded state.
	ld	e, d	; Replace primary key with secondary one.
	jr	.keypress
