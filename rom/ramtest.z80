	; TEST AND INITIALISE RAM
	; On entry, interrupts are disabled, and IM 1 is set.
	; RAM is tested with following patterns:
	;
	; 01010101 (0x55)
	; 10101010 (0xAA)
	; 00000000 (0x00) — last one clears RAM to all zeros.

RAM_TEST:
	xor a	; black
	out ($fe), a	; set border

	; Test 8 KB of RAM (enough to show splash animation)
	; RAM might not work, so returns to IY (instead of return address on stack)
.test_blocks:	ld bc,$0020	; Loop counters:
	ld hl,$3fff	; Start of RAM - 1
	ld iy,.FIRST_TEST_RETURN
	jp .do_test

.FIRST_TEST_RETURN:	jp z,INIT	; Fail fast if we have less than 8 KB of RAM.

.BAD_RAM_SIZE:	ld sp,.RAM_BAD_STACK
	ld de,.RAM_FAIL_TEXT
	ld bc,(.RAM_FAIL_LENGTH+1)<<8 | 30
	exx
	ld hl,$4000
	ld ix,FONT_LOOKUP
	jp render_common_char
.colour_the_text:
	ld hl,$5800	; Start of screen attributes
	ld bc, (11 << 8) | $42	; 16 cells, attribute $C2 (bright red on black)
.colour_loop:	ld (hl),c
	inc hl
	djnz .colour_loop
.BAD_RAM_HALT:	jr .BAD_RAM_HALT


.do_test:	ld de,$55aa	; First two test patterns: $55 and $aa.
.test_loop:	inc hl
	; 94 clocks per byte.
	ld a, d
	ld (hl),a
	cp (hl)
	jr nz,.test_end_fail
	ld a, e
	ld (hl),a
	cp (hl)
	jr nz,.test_end_fail
	xor a
	ld (hl),a
	cp (hl)
	jr nz,.test_end_fail
	djnz .do_test
	dec c
	jr nz,.do_test
.test_end_success:	jp (iy)	; Success. HL points to last successful byte.
.test_end_fail:	dec hl
	jp (iy)	; Failure. HL points to last successful byte.

	; We’re running when possibly none of the RAM works, so we can’t use a stack in RAM.
	; Instead, we use a small, hard-coded stack in ROM:
.RAM_BAD_STACK:	dw .colour_the_text
	dw $ffff	; AF: Set the carry flag to indicate failure

.RAM_FAIL_TEXT:	db " FAIL 16K RAM"
.RAM_FAIL_LENGTH:	equ $ - .RAM_FAIL_TEXT