; Some inspiration in the itoa conversion from
; https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/itoa_16.z80
; (Especially the adding negative numbers.)

atoi16:	push de
	push bc
	push ix
	ex de,hl
	ld ixh,d
	ld ixl,e	; IX: Output pointer.
	ld h,b
	ld l,c	; HL: int16 to convert.
	ld de,.table
	jr .find_first_digit	; TODO: jump 2 bytes (Z flag unset)

.find_first_digit_rpt:	sbc hl,bc
.find_first_digit:		; Clear carry flag.
	; Start with 5xs
	ex de,hl
	ld c,(hl)
	inc l
	ld b,(hl)
	inc l
	ex de,hl
	add hl,bc
	jr c,.found_5x
	sbc hl,bc
	; Next do 1xs
	ex de,hl
	ld c,(hl)
	inc l
	ld b,(hl)
	inc l
	ex de,hl
	add hl,bc
	jr nc,.find_first_digit_rpt

.found_1x:	ld a,'1'
	jr .increment

.found_5x:	ld a,'5'
.found_lt_5x:	ex de,hl
	ld c,(hl)
	inc l
	ld b,(hl)
	inc l	; BC has next (lower) power of ten
	ex de,hl
.increment:	add hl,bc
	inc a
	jr c,.increment
	sbc hl,bc
	dec a

	ld (ix),a	; Write a single digit.
	inc ix	; Increment output pointer.
	
	ex de,hl	; DE: has integer
	ld c,(hl)
	inc c
	jr z,.continue_8bit	; Exit if we found end of table (-1)
	dec c
	inc l
	ld b,(hl)
	inc l	; BC has next lower 5x power of ten
	ex de,hl
	add hl,bc
	jr c,.found_5x
	sbc hl,bc
	ld a,'0'
	jr .found_lt_5x

	SAME_PAGE .table_end
.table:	dw -50000
	dw -10000
	dw  -5000
	dw  -1000
	dw   -500
	dw   -100
	db -1
.table_end:

.continue_8bit:	ld a,e	; A: remaining two-decimal-digit int.
	ld e,ixl
	ld d,ixh	; DE: current character pointer.
	pop ix
	ld hl,INT8_TO_STRING.table_50
	ld b,(hl)
	jr INT8_TO_STRING.cmp_next_digit

	; Convert 16 bit int in BC (unsigned) to string at HL
	; Writes string at HL, returns HL at end of string.
	; Returns last ASCII digit in A.
	; MAX 1170 tstates (for ‘59999’). MIN 68 tstates (for ’0‘–‘9’)
INT16_TO_STRING:	xor a
	cp b
	jr nz,atoi16
	ld a,c
	; Fall through to 8-bit function:

	; Convert 8 bit int in A (unsigned) to string at HL
	; Writes string at HL, returns HL at end of string.
	; Returns last ASCII digit in A.
	; MAX 440 tstates (for ‘249’). MIN 49 tstates (for ’0‘–‘9’)
INT8_TO_STRING:	; [Will do full 16 (and 32?) bit numbers later.]
	cp 10
	jr c,.single_digit
	push de
	push bc
	ex de,hl
	ld hl,.table
	ld c,'0'

	cp (hl)
	jr nc,.found_digit	; ≥100
	inc l
	cp (hl)
	jr c,.found_10	; ≥10 (by default)
		; Or ≥50
.found_50:	sub (hl)
	ld c,'5'
.found_10:	inc l
.found_digit:	ld b,(hl)
.increment:	inc c
	sub b
	jr nc,.increment
	add b
	dec c
	ex de,hl
	ld (hl),c
	inc hl
	ex de,hl

	inc l
	ld b,(hl)
	inc b
	dec b
	jr z,.last_digit
.cmp_next_digit:	cp b
	jr nc,.found_50
	ld c,'0'
	jr .found_10

.last_digit:	ex de,hl
	pop bc
	pop de
.single_digit:	add '0'
	ld (hl),a
	inc hl
	ret

	SAME_PAGE .table_end
.table:	db 100
.table_50:	db 50
	db 10
	db 0
.table_end: