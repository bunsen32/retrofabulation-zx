; Some inspiration in the itoa conversion from
; https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/itoa_16.z80
; (Especially the adding negative numbers.)

atoi16:	push bc
	push de
	ex de,hl	; DE: Output pointer.
	ld h,b
	ld l,c	; HL: int16 to convert.

	ld bc,-50000
	add hl,bc
	ld a,'5'-1
	jr c,.tenthousands_init
	sbc hl,bc
	
	ld bc,-10000
	add hl,bc
	ld a,'1'-1
	jr c,.tenthousands_loop
	sbc hl,bc

	ld bc,-5000
	add hl,bc
	ld a,'5'-1
	jr c,.thousands_init
	sbc hl,bc
	
	ld bc,-1000
	add hl,bc
	ld a,'1'-1
	jr c,.thousands_loop
	sbc hl,bc
	jr .hundreds

.tenthousands_init:	ld bc,-10000
.tenthousands_loop:	add hl,bc
	inc a
	jr c,.tenthousands_loop
	sbc hl,bc
	ld (de),a
	inc de

.thousands:	ld bc,-5000
	add hl,bc
	ld a,'5'-1
	jr c,.thousands_init
	sbc hl,bc
	ld a,'0'-1
.thousands_init:	ld bc,-1000
.thousands_loop:	add hl,bc
	inc a
	jr c,.thousands_loop
	sbc hl,bc
	ld (de),a
	inc de

.hundreds:	ld bc,-500
	add hl,bc
	ld a,'5'-1
	jr c,.hundreds_init
	sbc hl,bc
	ld a,'0'-1
.hundreds_init:	ld bc,-100
.hundreds_loop:	add hl,bc
	inc a
	jr c,.hundreds_loop
	sbc hl,bc
	ld (de),a
	inc de

.continue_8bit:	ld a,l	; A: remaining two-decimal-digit int.
	ex de,hl	; HL: output pointer
	pop de
	jr INT8_TO_STRING.tens

	; Convert 16 bit int in BC (unsigned) to string at HL
	; Writes string at HL, returns HL at end of string.
	; Returns last ASCII digit in A.
	; MAX 800 tstates (for ‘59999’). MIN 68 tstates (for ’0‘–‘9’)
INT16_TO_STRING:	xor a
	cp b
	jr nz,atoi16
	ld a,c
	; Fall through to 8-bit function:

	; Convert 8 bit int in A (unsigned) to string at HL
	; Writes string at HL, returns HL at end of string.
	; Returns last ASCII digit in A.
	; MAX 274 tstates (for ‘249’). MIN 49 tstates (for ’0‘–‘9’)
INT8_TO_STRING:	; [Will do full 16 (and 32?) bit numbers later.]
	cp 10
	jr c,.single_digit
	push bc
	cp 100
	jr c,.tens
	sub 200
	ld c,'2'
	jr nc,.ge_200
	add 100
	ld c,'1'
.ge_200:	ld (hl),c
	inc hl
.tens:	ld bc,10 << 8 | ('0' - 1)	; B := 10 (to subtract from A); C := one before '0' (starting digit)
	cp 50
	jr c,.lt_50
	sub 50
	ld c,'5' - 1
.lt_50:	inc c
	sub b
	jr nc,.lt_50
	add b
	ld (hl),c
	inc hl
	pop bc
.single_digit:	add '0'
	ld (hl),a
	inc hl
	ret

