; Some inspiration in the itoa conversion from
; https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/itoa_16.z80
; (Especially the adding negative numbers.)

atoi16:	push bc
	push de
	push ix
	ex de,hl
	ld ixh,d
	ld ixl,e	; IX: Output pointer.
	ld h,b
	ld l,c	; HL: int16 to convert.
	ld de,.table
	jr .find_first_digit	; TODO: jump 2 bytes (Z flag unset)

.find_first_digit_rpt:	sbc hl,bc
.find_first_digit:		; Clear carry flag.
	; Start with 5xs
	ex de,hl
	ld c,(hl)
	inc l
	ld b,(hl)
	inc l
	ex de,hl
	add hl,bc
	jr c,.found_5x
	sbc hl,bc
	; Next do 1xs
	ex de,hl
	ld c,(hl)
	inc l
	ld b,(hl)
	inc l
	ex de,hl
	add hl,bc
	jr nc,.find_first_digit_rpt

.found_1x:	ld a,'1'
	jr .increment

.found_5x:	ld a,'5'
.found_lt_5x:	ex de,hl
	ld c,(hl)
	inc l
	ld b,(hl)
	inc l	; BC has next (lower) power of ten
	ex de,hl
.increment:	add hl,bc
	inc a
	jr c,.increment
	sbc hl,bc
	dec a

	ld (ix),a	; Write a single digit.
	inc ix	; Increment output pointer.
	
	ex de,hl	; DE: has integer
	ld c,(hl)
	inc c
	jr z,.continue_8bit	; Exit if we found end of table (-1)
	dec c
	inc l
	ld b,(hl)
	inc l	; BC has next lower 5x power of ten
	ex de,hl
	add hl,bc
	jr c,.found_5x
	sbc hl,bc
	ld a,'0'
	jr .found_lt_5x

	SAME_PAGE .table_end
.table:	dw -50000
	dw -10000
	dw  -5000
	dw  -1000
	dw   -500
	dw   -100
	db -1
.table_end:

.continue_8bit:	ld a,e	; A: remaining two-decimal-digit int.
	ld e,ixl
	ld d,ixh	; DE: current character pointer.
	ex de,hl
	pop ix
	pop de
	jr INT8_TO_STRING.tens

	; Convert 16 bit int in BC (unsigned) to string at HL
	; Writes string at HL, returns HL at end of string.
	; Returns last ASCII digit in A.
	; MAX 1170 tstates (for ‘59999’). MIN 68 tstates (for ’0‘–‘9’)
INT16_TO_STRING:	xor a
	cp b
	jr nz,atoi16
	ld a,c
	; Fall through to 8-bit function:

	; Convert 8 bit int in A (unsigned) to string at HL
	; Writes string at HL, returns HL at end of string.
	; Returns last ASCII digit in A.
	; MAX 274 tstates (for ‘249’). MIN 49 tstates (for ’0‘–‘9’)
INT8_TO_STRING:	; [Will do full 16 (and 32?) bit numbers later.]
	cp 10
	jr c,.single_digit
	push bc
	cp 100
	jr c,.tens
	sub 200
	ld c,'2'
	jr nc,.ge_200
	add 100
	ld c,'1'
.ge_200:	ld (hl),c
	inc hl
.tens:	ld bc,10 << 8 | ('0' - 1)	; B := 10 (to subtract from A); C := one before '0' (starting digit)
	cp 50
	jr c,.lt_50
	sub 50
	ld c,'5' - 1
.lt_50:	inc c
	sub b
	jr nc,.lt_50
	add b
	ld (hl),c
	inc hl
	pop bc
.single_digit:	add '0'
	ld (hl),a
	inc hl
	ret

