TEXT_BUFFER	EQU	$5B80

SCR_CUR_UP	EQU	0b0001
SCR_CUR_DOWN	EQU	0b0011
SCR_SHOW_CURSOR	EQU	$80
SCR_REDRAW_TEXT	EQU	0b0010
SCR_ISSUE_RIGHT	EQU	0b0100

	; Read-Execute-Print Loop
POP_AND_REPL:
	pop	bc	; Pop off a return address
REPL:
.cls
	ld	a,7
	out	($fe),a	; Set border to white
	ld	hl,$5800
	ld	(hl),0b00111111	; White ink; white paper
	ld	de,$5801
	ld	bc,768
	ldir		; Clear screen to all white (16123 t-states)
.init_buffer:
	ld	de, TEXT_BUFFER
	ld	bc, 0	; prior-chars := 0; subsequent-chars := 0
	exx
	ld	b,$ff	; Max length
	ld	c,1	; Current line number
	ld	hl, $0300
	push	hl
	exx
	pop	hl
	ld	(CURSOR_XY), hl

	; Clear first character cell so that flashing cursor is visible:
	push	bc
	push	de
	push	hl
	ld	de,TWO_SPACES
	ld	b,1
	ld	a,0b01111000	; black ink, white paper
	call	RENDER_TEXT
	pop	hl
	pop	de
	pop	bc

	; Push first line buffer position onto stack:
	push	de	

	; Buffer: [xxxxxx|xxxx-----]
	; A: scratch register
	; HL: screen position of cursor (row,half-cell)
	; DE: buffer position of cursor (byte pointer)
	; B : characters prior to cursor
	; C : characters after cursor
	; B': remaining space in buffer (characters)
	; C': Current line number (1-based)
	; HL': screen position of column-zero (row,half-cell)
	; (SP): buffer position of column-zero (we push lines on, and pop them off)
REPL_LOOP:	
.check_key:
	ld	a, (KEY_CHAR)
	or	a
	call	nz,LINE_EDIT	; Returns with ‘screen-editing’ command (or zero).
	or	a
	jr	nz,.screen_cmd
.await	halt		; Wait for some potential keyboard input.
	call	CURSOR_ANIM_FRAME
	jr	.check_key

	; Cycle back round again and move cursor right
.right_by_one:	ld	a,CHAR_RIGHT
	call	LINE_EDIT
	; fallthrough to .screen_cmd

	// If we get here, we (might) need to move between lines, or redraw the display.
	// Implies a cursor move/reset too. Takes in bits of A:
	// 0: Vertical move to next or previous line? (0 = NO, 1 = YES)
	// 1:   0 = vertical move UP; 1 = vertical move DOWN
	// 1: Redraw? (0 = NO, 1 = YES)
	// 2: Issue CURSOR_RIGHT key to move cursor after inserting a character.
	// 3–6: <unused>
	// 7: (Can be set to 1 to show cursor and do nothing else.)
.screen_cmd:	ex	af,af'
	call	HIDE_CURSOR
	ex	af,af'
.bit_A:
	rra		; Bit A+0: vertical movement (up or down arrow)
	jr	c,.mov_vertical

	// Sort out cursor position. If it’s to the left of the allowed screen area,
	// move it to the end of the previous line (minus one character); if it’s
	// to the right of allowed screen area, move it to start of next line (plus one
	// character). Assumes that previous code has checked that it’s a valid character
	// position.
.fixup_cursor:	ex	af,af'
	ld	a,l
	cp	-4
	jr	nc,.wrap_to_prev_ln	; If -4, -3, -2, -1, move to prev line. 
	sub	65
	jr	c,.ex_bit_B	; ≤ margin (64): do nothing.

.wrap_to_next_ln:
	dec	de	; Go 1 char to left in buffer (we’ll go back at the end)
	push	de	; That’s the new line buffer start
	dec	b
	inc	c	; Adjust B & C to match
	exx
	inc	h	; Line start down by 1 line
	push	hl
	exx
	pop	hl	; Cursor position to start of new line.
	jr	.right_by_one	; Now go 1 right, to original buffer position.

.wrap_to_prev_ln:
	pop	hl	; We’re going to discard previous HL (cursor coordinates)
	pop	hl	; HL: previous line buffer position
	push	hl	; …and stick it back on the stack.
	exx
	dec	h	; Previous line row-number
	push	hl	; (SP) := coords of start of previous line
	exx
	ex	de,hl	; HL: current p (buffer); DE: prev line start (buffer)
	or	a	; (clear carry flag)
	sbc	hl,de	; HL: distance along previous line in characters (<256 so only L is significant)
	push	bc
	ld	b,l	; B := distance along prev line in characters
	ld	c,64	; C := maximum line width (= "no limit")
	call	MEASURE_SPAN	; DE := cursor buffer position; C := offset from left margin
	ld	a,c	; A := measured width of line
	pop	bc
	pop	hl	; HL := HL'
	add	l	; A := width of line + left margin
	ld	l,a	; L (cursor X) := width of line + left margin

.ex_bit_B:	ex	af,af'
.bit_B:	rra		; Bit B: redraw
	jr	nc,.bit_C
	push	af
	push	hl
	ld	a,0b01111000	; black ink, white paper
	call	PRINT_WRAP
	pop	hl
	pop	af

.bit_C:
	rra		; Bit C: right-arrow
	jr	c,.right_by_one

.set_ideal_x:	; Set the up-down target horizontal position:
	ld	a,l
	ld	(IDEAL_CUR_X),a
.end_screen_cmd:	; Set new cursor position & display it:
	ld	(CURSOR_XY),hl
	call	SHOW_CURSOR
	jr	.await

.mov_vertical:	rra		; Bit A+1: 0=UP 1=DOWN
	jr	c,.mv_down

.mv_up:	; First: Move to start of CURRENT line:
	pop	hl	; Discard cursor posn & HL := buffer start of line
	push	hl	; (keep it on the stack)
	call	MV_HOME
	inc	b
	dec	b	; Check non-zero number of prior characters (and hence prior lines)	
	jr	z,.set_ideal_x	; No prior lines? Stop here (with cursor at start of first line)

	; Next: Move to start of PREVIOUS line:
	exx
	dec	h	; Move up a line
	exx
	pop	hl	; Discard cursor posn & HL := buffer start of current line
	pop	hl	; HL := buffer start of PREVIOUS line
	push	hl	; (keep it on the stack)
	call	MV_HOME

	; Last: Find desired cursor position:
	jr	.mv_to_ideal_x

.mv_down:	; First: Move to end of CURRENT line:
	push	bc
	ld	b,c	; B := # subsequent characters
	ld	a,64
	sub	l	; A := column space to end of line
	ld	c,a	; C := allowed columns for characters
	call	MEASURE_SPAN
	ld	a,l
	add	c	; A: = L (cursor-X) + span width
	ld	l,a	; L := position of end of line
	ld	a,b	; A := chars to end of line
	pop	bc
	call	.fixup_bc
	inc	c
	dec	c	; Check non-zero number of subsequent characters (and hence subsequent lines)	
	jr	z,.set_ideal_x	; No subsequent lines? Stop here (with cursor at end of last line)

	; Next: Position cursor at start of NEXT line:
	push	de
	exx
	inc	h
	push	hl
	exx
	pop	hl

.mv_to_ideal_x	; Last: Find desired cursor position:
	push	bc
	ld	b,c	; B := number of characters after cursor
	ld	a,(IDEAL_CUR_X)
	sub	l
	ld	c,a	; C := (IDEAL_CUR_X - left margin)
	call	MEASURE_SPAN
	ld	a,l
	add	c
	ld	l,a	; L (cursor X) := desired position
	ld	a,b	; A := count of characters to desired position
	pop	bc
	call	.fixup_bc

	jr	.end_screen_cmd

.fixup_bc:	; Add A to B; Subtract A from C. (Only save 1 byte by making this subroutine with 2 uses!)
	push	af
	add	b
	ld	b,a	; B := B + (char count)
	pop	af
	neg
	add	c
	ld	c,a	; C := C + (char count)
	ret

	; Move to the start of the line.
	; NEED TO: 'pop HL' before calling. (Which discards cursor position & retrieve start of line)
	; Does not do any screen cursor manipulation
	; RETURNS
	; DE: New buffer position
	; HL: New cursor coords
	; B & C: Fixed-up ‘prior’ & ‘subsequent’ character counts.
	; A: <trashed>
MV_HOME:	ex	de,hl	; DE := buffer position start of line (HL := prev buffer posn)
	or	a	; clear carry flag
	sbc	hl,de	; L := characters to start of line
	ld	a,b
	sub	l
	ld	b,a	; B := characters prior to start of line
	ld	a,c
	add	l
	ld	c,a	; C := characters
	exx
	push	hl
	exx
	pop	hl	; HL := screen coords for start of line
	ret
	

	// Subroutine for the movement and editing operations within a single line.
	// If we require a movement between lines, (or redraw of other lines),
	// return a ‘screen command’.
	// A = pressed character code
	// RETURNS
	// A = ‘screen command’
LINE_EDIT:	; A != 0
	cp	$10	; no-carry == printable character
	jr	nc, .try_insert

	rra
	jr	c,.char_xxx1

.char_xxx0:	rra
	jr	c,.char_xx10
.char_xx00:	rra
	;jr	c,.char_x100	; [This check is inverted on next line.]

.char_x000:	; BACKSPACE (1000) because 0000 is not passed
.BACKSPACE:	jp	nc,DEL_BACKSPACE

.char_x100:	; UP (0100) because 1100 ($C) is not passed
.UP:	ld	a,SCR_CUR_UP	; Screen command: move down
	ret

.char_xx10:	rra
	jr	c,.char_x110
.char_x010:	; RIGHT (0010) because 1010 ($A) is not used
.RIGHT:	jp	CURSOR_RIGHT	; (Tail call)

.char_x110:	rra
	jr	c,.char_1110

.char_0110:	; TRU VID (0110) $06
.TRU_VID:	xor	a	; TODO
	ret

.char_1110:	; CAPS LOCK (1110) $0E
.CAPS_LOCK:	ld	a,$e
	jr	.try_insert	; TODO

.char_xxx1:	rra
	jr	c,.char_xx11
.char_xx01:	rra
	jr	c,.char_x101

.char_x001:	; LEFT (0001) because 1001 ($9) is not used
.LEFT:	jp	CURSOR_LEFT	; (Tail call)

.char_x101:	; INV-VID (0101) because 1101 ($D) is not used
.INV_VID:	xor	a	; TODO
	ret

.char_xx11:	rra
	jr	c,.char_x111
.char_x011:	rra
	jr	c,.char_1011
.char_0011:	; DOWN (0011) $03
.DOWN:	ld	a,SCR_CUR_DOWN	; Screen command: move down
	ret

.char_1011:	; ESC/EDIT (1011) $0B
.ESC_EDIT:	xor	a	; TODO
	ret

.char_x111:	; GFX (1111) because 0111 ($07) is not used
.GFX:	xor	a	; TODO
	ret

.try_insert:
	exx
	inc	b
	dec	b
	jr	z,.exx_ret
	dec	b	; Reduce buffer space.
	exx

	push	af
	inc	c
	dec	c	; Characters after cursor
	jr	z,.after_ins_move	; If zero, nothing to move.
	push	hl
	push	de
	push	bc
	ld	b,0	; C already has letters-to-end.
	ex	de,hl
	add	hl,bc
	ld	d,h
	ld	e,l
	dec	hl
	lddr
	pop	bc
	pop	de
	pop	hl
.after_ins_move:
	pop	af
	ld	(de), a	; Put the character into the buffer
	inc	c	; Number of characters to the right

			; Redraw the screen (including newly inserted char), and move cursor right:
	ld	a,SCR_REDRAW_TEXT|SCR_ISSUE_RIGHT
	ret

	; No space in buffer, so exit:
.exx_ret:	exx
	xor	a
	ret

DEL_BACKSPACE:
	dec	b
	inc	b
	ret	z	; Nothing to delete.
	dec	b	; characters to left -= 1

	dec	de	; Move back to character to be deleted.
	ld	a,(de)	; Get it
	call	MEASURE_CHAR	; Measure it
	neg		; 0 - column-width
	add	l	; Add to cursor column
	ld	l,a	; Cursor column -= deleted character width

	exx
	inc	b	; Buffer has space for one more char.
	exx

.del_move:
	inc	c
	dec	c	; Characters after cursor
	jr	z,.after_del_move	; If zero, nothing to move.
	push	hl
	push	de
	push	bc
	ld	b,0	; C already has letters-to-end.
	ld	h,d
	ld	l,e
	inc	hl
	ldir
	pop	bc
	pop	de
	pop	hl
.after_del_move:
	call	HIDE_CURSOR
	ld	a,SCR_REDRAW_TEXT|SCR_SHOW_CURSOR
	ret

	; Renders multiple lines of text, until the end of the buffer:
	; Takes:
	; A = attr, B = char count, DE = char pointer, HL = initial coords
	; HL' coords of start of line.
	; RETURNS:
	; HL = coords of the end of last line.
	; On stack: start of last line.
PRINT_WRAP:
	push	bc
	push	de
	ld	b,c	; b := total characters to render.
	exx
	push	hl	; Push start of line.
	exx
	jr	.first_line

.next_line:	pop	hl	; Pop start of line.
	inc	h	; Down one line
	push	hl	; Push start of line.
.first_line:
	call	RENDER_TEXT	; Render as much as we can (stopping at end of line)
	
	push	bc
	push	de
	ld	de, TWO_SPACES
	ld	b,2
	call	RENDER_TEXT	; Erase any junk at end of line.
	pop	de	; de := next character (start of next line)
	pop	bc	; b := remaining characters to render

	inc	b
	djnz	.next_line	; Loop if more characters (lines) to render.
	pop	de	; pop (and discard) start-of-line (was HL)
	pop	de
	pop	bc
	ret

TWO_SPACES	db	' ', ' '

CURSOR_LEFT:
	xor	a	; (In case we need to exit early with NOP)
	dec	b
	inc	b
	ret	z	; We’ve hit the left limit

	dec	b	; 1 more left
	inc	c	; 1 less right
	dec	de	; Back 1 char byte
	ld	a,(de)	; Get prev char
	call	MEASURE_CHAR	; Width in half-cells
	neg
	add	l
	ld	l,a
	jr	HIDE_AND_LD_CUR	; (Tail call)

CURSOR_RIGHT:
	xor	a	; (In case we need to exit early with NOP)
	dec	c
	inc	c
	ret	z	; We’ve hit the right limit

	dec	c	; 1 more right
	inc	b	; 1 less left
	ld	a,(de)	; Get current char
	call	MEASURE_CHAR	; Width in half-cells
	inc	de	; Forward 1 char byte
	add	l
	ld	l,a
	jr	HIDE_AND_LD_CUR	; (Tail call)

CURSOR_UP:	; TODO
	ret

CURSOR_DOWN:	; TODO
	ret

HIDE_AND_LD_CUR:	call	HIDE_CURSOR
	ld	(CURSOR_XY), hl
	ld	a,SCR_SHOW_CURSOR
	ret

	; Display cursor on the screen, if it is not already shown.
	; Either way, extend animation frame count for visible cursor.
	; (Extend the displayed lifespan.)
	; Trashes: A
SHOW_CURSOR:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	ld	(hl), (CURSOR_FLASH_RATE << 1) | 1
	rra		; Examine previous value of bit zero…
	jr	nc,CURSOR_XOR.after_pushes_HL
	pop	hl
	ret

	; Hide the cursor, if it is shown.
	; Trashes: A
HIDE_CURSOR:
	ld	a, (CURSOR_FRAMES)
	rra
	ret	nc	; Cursor not on screen anyway
	xor	a	; Cursor WAS on screen…
	ld	(CURSOR_FRAMES), a	; And store back in variable.
	jr	CURSOR_XOR

	; Decrement the frame counter and show or hide the cursor
	; Trashes: A
CURSOR_ANIM_FRAME:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	srl	a
	dec	a
	jr	z, .statechange
	rla		; Put <carry> back into posn 0
	ld	(hl), a	; And store back in variable.
	pop	hl
	ret
.statechange:
	rla		; Move <carry> back into low bit
	xor	(CURSOR_FLASH_RATE << 1) | 1	; Add back in count and invert bit zero
.store_and_xor:	ld	(hl), a
	jr	CURSOR_XOR.after_pushes_HL

	; Invert cursor pixels. Current cursor posn is held in (CURSOR_XY)
	; TODO: Doesn’t show cursor on last col of screen (64). SHould do.
	; Trashes: A
CURSOR_XOR:
	push	hl
.after_pushes_HL
	push	de
	push	bc
	ld	b, 8
	ld	hl, (CURSOR_XY)
	call	ROWCOL_ADDR
	bit	5, d
	jr	nz, .halfcol
.cellboundary:
.loop0:	ld	a, (de)
	xor	0b10000000
	ld	(de), a
	inc	d
	djnz	.loop0
	dec	e
	jp	m,.pop_and_return	; Return if we were in the first column
	ld	b, 8	; Otherwise…
.loop0B:	dec	d
	ld	a, (de)
	xor	1
	ld	(de), a
	djnz	.loop0B
.pop_and_return:
	pop	bc
	pop	de
	pop	hl
	ret
.halfcol:
	res	5, d
.loop1:	ld	a, (de)
	xor	0b00011000
	ld	(de), a
	inc	d
	djnz	.loop1
	jr	.pop_and_return