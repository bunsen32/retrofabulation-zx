TEXT_BUFFER	EQU	$5B80

	; Read-Execute-Print Loop
POP_AND_REPL:
	pop	bc	; Pop off a return address
REPL:
.cls
	ld	a,7
	out	($fe),a	; Set border to white
	ld	hl,$5800
	ld	(hl),0b00111111	; White ink; white paper
	ld	de,$5801
	ld	bc,768
	ldir		; Clear screen to all white (16123 t-states)
.init_buffer:
	exx
	ld	c,30	; Max length
	exx
	ld	de, TEXT_BUFFER
	ld	bc, 0
	ld	hl, $0300
	ld	(CURSOR_XY), hl

	; Buffer: [xxxxxx|xxxx-----]
	; A: scratch register
	; HL: screen position of cursor (row,half-cell)
	; DE: buffer position of cursor (byte pointer)
	; B : characters prior to cursor
	; C : characters after cursor
	; B': remaining space in buffer (characters)
	; C': remaining space on screen (half-cells)
REPL_LOOP:	
.check_key:
	ld	a, (KEY_CHAR)
	or	a
	jr	nz,.keypress
.await	halt		; Wait for some potential keyboard input.
	call	CURSOR_ANIM_FRAME
	jr	.check_key
.keypress:	; A != 0
	cp	$10	; no-carry == printable character
	jr	nc, .try_insert
	rra
	jr	c,.char_xxx1

.char_xxx0:	rra
	jr	c,.char_xx10
.char_xx00:	rra
	;jr	c,.char_x100	; [This check is inverted on next line.]

.char_x000:	; BACKSPACE (1000) because 0000 is not passed
.BACKSPACE:	jp	nc,.try_delete

.char_x100:	; UP (0100) because 1100 ($C) is not passed
.UP:	jr	.await	; TODO

.char_xx10:	rra
	jr	c,.char_x110
.char_x010:	; RIGHT (0010) because 1010 ($A) is not used
.RIGHT:	dec	c
	inc	c
	jr	z,.await	; We’ve hit the right limit
	dec	c	; 1 more right
	inc	b	; 1 less left
	ld	a,(de)	; Get current char
	call	MEASURE_CHAR	; Width in half-cells
	inc	de	; Forward 1 char byte
	add	l
	ld	l,a
	call	MOVE_CURSOR
	jr	.await

.char_x110:	rra
	jr	c,.char_1110

.char_0110:	; TRU VID (0110) $06
.TRU_VID:	jr	.await	; TODO

.char_1110:	; CAPS LOCK (1110) $0E
.CAPS_LOCK:	ld	a,$e
	jr	.try_insert	; TODO

.char_xxx1:	rra
	jr	c,.char_xx11
.char_xx01:	rra
	jr	c,.char_x101

.char_x001:	; LEFT (0001) because 1001 ($9) is not used
.LEFT:	dec	b
	inc	b
	jr	z,.await	; We’ve hit the left limit
	dec	b	; 1 more left
	inc	c	; 1 less right
	dec	de	; Back 1 char byte
	ld	a,(de)	; Get prev char
	call	MEASURE_CHAR	; Width in half-cells
	neg
	add	l
	ld	l,a
	call	MOVE_CURSOR
	jr	.await

.char_x101:	; INV-VID (0101) because 1101 ($D) is not used
.INV_VID:	jr	.await	; TODO

.char_xx11:	rra
	jr	.char_x111
.char_x011:	rra
	jr	.char_1011
.char_0011:	; DOWN (0011) $03
.DOWN	jr	.await	; TODO

.char_1011:	; ESC/EDIT (1011) $0B
.ESC_EDIT	jr	.await	; TODO

.char_x111:	; GFX (1111) because 0111 ($07) is not used
.GFX	jr	.await	; TODO

.try_insert:
	push	af
	call	MEASURE_CHAR
	exx
	inc	c
	dec	c
	jr	z,.exx_await
	dec	c	; Reduce buffer space.
	exx

	inc	c
	dec	c	; Characters after cursor
	jr	z,.after_ins_move	; If zero, nothing to move.
	push	hl
	push	de
	push	bc
	ld	b,0	; C already has letters-to-end.
	ex	de,hl
	add	hl,bc
	ld	d,h
	ld	e,l
	dec	hl
	lddr
	pop	bc
	pop	de
	pop	hl
.after_ins_move:
	call	HIDE_CURSOR
	inc	b	; Number of characters to the left
	pop	af
	ld	(de), a	; Put the character into the buffer

	; Print inserted character:
	push	de
	push	bc
	ld	b,1	; single character
	ld	a,0b01111000	; black ink, white paper
	call	render_text	; HL is updated with new cursor posn
	pop	bc
	pop	de
	inc	de	; Increase buffer position.

	; (Re)print remaining characters:
.reprint_remain:	push	de
	push	bc
	push	hl
	ld	b,c
	ld	a,0b01111000	; black ink, white paper
	call	render_text
.after_insert:
	pop	hl
	pop	bc
	pop	de
	call	MOVE_CURSOR
	exx
.exx_await:	exx
.jp_await:	jp	.await

.try_delete:
	dec	b
	inc	b
	jr	z,.jp_await	; Nothing to delete.

	dec	de	; Move back to character to be deleted.
	ld	a,(de)	; Get it
	call	MEASURE_CHAR	; Measure it
	neg		; 0 - column-width
	add	l	; Add to cursor column
	ld	l,a	; Cursor column -= deleted character width

	exx
	inc	c	; Buffer has space for one more char.
	exx
.del_move:
	inc	c
	dec	c	; Characters after cursor
	jr	z,.after_del_move	; If zero, nothing to move.
	push	hl
	push	de
	push	bc
	ld	b,0	; C already has letters-to-end.
	ld	h,d
	ld	l,e
	inc	hl
	ldir
	pop	bc
	pop	de
	pop	hl
.after_del_move:
	dec	b	; characters to left -= 1
	call	HIDE_CURSOR
	jr	.reprint_remain	; (Re)print remaining characters (possibly zero)

	; Moves cursor to coordinates indicated by HL
	; Trashes A
MOVE_CURSOR:	call	HIDE_CURSOR
	ld	(CURSOR_XY), hl
	jp	SHOW_CURSOR	; Tail call.

	; Display cursor on the screen, if it is not already shown.
	; Either way, extend animation frame count for visible cursor.
	; (Extend the displayed lifespan.)
	; Trashes: A
SHOW_CURSOR:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	ld	(hl), (CURSOR_FLASH_RATE << 1) | 1
	rra		; Examine previous value of bit zero…
	jr	nc,CURSOR_XOR.after_pushes_HL
	pop	hl
	ret

	; Hide the cursor, if it is shown.
	; Trashes: A
HIDE_CURSOR:
	ld	a, (CURSOR_FRAMES)
	rra
	ret	nc	; Cursor not on screen anyway
	xor	a	; Cursor WAS on screen…
	ld	(CURSOR_FRAMES), a	; And store back in variable.
	jr	CURSOR_XOR

	; Decrement the frame counter and show or hide the cursor
	; Trashes: A
CURSOR_ANIM_FRAME:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	srl	a
	dec	a
	jr	z, .statechange
	rla		; Put <carry> back into posn 0
	ld	(hl), a	; And store back in variable.
	pop	hl
	ret
.statechange:
	rla		; Move <carry> back into low bit
	xor	(CURSOR_FLASH_RATE << 1) | 1	; Add back in count and invert bit zero
.store_and_xor:	ld	(hl), a
	jr	CURSOR_XOR.after_pushes_HL

	; Invert cursor pixels. Current cursor posn is held in (CURSOR_XY)
	; Trashes: A
CURSOR_XOR:
	push	hl
.after_pushes_HL
	push	de
	push	bc
	ld	b, 8
	ld	hl, (CURSOR_XY)
	call	ROWCOL_ADDR
	bit	5, d
	jr	nz, .halfcol
.cellboundary:
.loop0:	ld	a, (de)
	xor	0b10000000
	ld	(de), a
	inc	d
	djnz	.loop0
	dec	e
	jp	m,.pop_and_return	; Return if we were in the first column
	ld	b, 8	; Otherwise…
.loop0B:	dec	d
	ld	a, (de)
	xor	1
	ld	(de), a
	djnz	.loop0B
.pop_and_return:
	pop	bc
	pop	de
	pop	hl
	ret
.halfcol:
	res	5, d
.loop1:	ld	a, (de)
	xor	0b00011000
	ld	(de), a
	inc	d
	djnz	.loop1
	jr	.pop_and_return