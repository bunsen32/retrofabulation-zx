TEXT_BUFFER	EQU	$5B80

	; Read-Execute-Print Loop
POP_AND_REPL:
	pop	bc	; Pop off a return address
REPL:
.cls
	ld	a,7
	out	($fe),a	; Set border to white
	ld	hl,$5800
	ld	(hl),0b00111111	; White ink; white paper
	ld	de,$5801
	ld	bc,768
	ldir		; Clear screen to all white (16123 t-states)
.init_buffer:
	exx
	ld	b,$ff	; Max length
	ld	c,1	; Current line number
	ld	de, TEXT_BUFFER
	ld	hl, $0300
	push	hl
	push	de

	exx
	pop	de
	pop	hl
	ld	bc, 0
	ld	(CURSOR_XY), hl

	; Buffer: [xxxxxx|xxxx-----]
	; A: scratch register
	; HL: screen position of cursor (row,half-cell)
	; DE: buffer position of cursor (byte pointer)
	; B : characters prior to cursor
	; C : characters after cursor
	; B': remaining space in buffer (characters)
	; C': Current line number (1-based)
	; HL': screen position of column-zero (row,half-cell)
	; DE': buffer position of column-zero
REPL_LOOP:	
.check_key:
	ld	a, (KEY_CHAR)
	or	a
	call	nz,.keypress
	halt		; Wait for some potential keyboard input.
	call	CURSOR_ANIM_FRAME
	jr	.check_key
	
.keypress:	; A != 0
	cp	$10	; no-carry == printable character
	jr	nc, .try_insert

	rra
	jr	c,.char_xxx1

.char_xxx0:	rra
	jr	c,.char_xx10
.char_xx00:	rra
	;jr	c,.char_x100	; [This check is inverted on next line.]

.char_x000:	; BACKSPACE (1000) because 0000 is not passed
.BACKSPACE:	jp	nc,.try_delete

.char_x100:	; UP (0100) because 1100 ($C) is not passed
.UP:	jp	CURSOR_UP	; (Tail call)

.char_xx10:	rra
	jr	c,.char_x110
.char_x010:	; RIGHT (0010) because 1010 ($A) is not used
.RIGHT:
	call	CURSOR_RIGHT
	jp	SHOW_CURSOR	; (Tail call)

.char_x110:	rra
	jr	c,.char_1110

.char_0110:	; TRU VID (0110) $06
.TRU_VID:	ret		; TODO

.char_1110:	; CAPS LOCK (1110) $0E
.CAPS_LOCK:	ld	a,$e
	jr	.try_insert	; TODO

.char_xxx1:	rra
	jr	c,.char_xx11
.char_xx01:	rra
	jr	c,.char_x101

.char_x001:	; LEFT (0001) because 1001 ($9) is not used
.LEFT:
	call	CURSOR_LEFT
	jp	SHOW_CURSOR	; (Tail call)

.char_x101:	; INV-VID (0101) because 1101 ($D) is not used
.INV_VID:	ret		; TODO

.char_xx11:	rra
	jr	.char_x111
.char_x011:	rra
	jr	.char_1011
.char_0011:	; DOWN (0011) $03
.DOWN	jp	CURSOR_DOWN	; (Tail call)

.char_1011:	; ESC/EDIT (1011) $0B
.ESC_EDIT	ret		; TODO

.char_x111:	; GFX (1111) because 0111 ($07) is not used
.GFX	ret		; TODO

.try_insert:
	push	af
	exx
	inc	b
	dec	b
	jr	z,.exx_ret
	dec	b	; Reduce buffer space.
	exx

	inc	c
	dec	c	; Characters after cursor
	jr	z,.after_ins_move	; If zero, nothing to move.
	push	hl
	push	de
	push	bc
	ld	b,0	; C already has letters-to-end.
	ex	de,hl
	add	hl,bc
	ld	d,h
	ld	e,l
	dec	hl
	lddr
	pop	bc
	pop	de
	pop	hl
.after_ins_move:
	pop	af
	ld	(de), a	; Put the character into the buffer
	inc	c	; Number of characters to the right

	; Print inserted character:
	call	HIDE_CURSOR
	push	hl
	ld	a,0b01111000	; black ink, white paper
	call	PRINT_WRAP
	pop	hl
	call	CURSOR_RIGHT
	jp	SHOW_CURSOR	; (Tail call)

	; (Re)print remaining characters:
.exx_ret:	exx
	ret

.try_delete:
	dec	b
	inc	b
	ret	z	; Nothing to delete.

	dec	de	; Move back to character to be deleted.
	ld	a,(de)	; Get it
	call	MEASURE_CHAR	; Measure it
	neg		; 0 - column-width
	add	l	; Add to cursor column
	ld	l,a	; Cursor column -= deleted character width

	exx
	inc	b	; Buffer has space for one more char.
	exx
.del_move:
	inc	c
	dec	c	; Characters after cursor
	jr	z,.after_del_move	; If zero, nothing to move.
	push	hl
	push	de
	push	bc
	ld	b,0	; C already has letters-to-end.
	ld	h,d
	ld	l,e
	inc	hl
	ldir
	pop	bc
	pop	de
	pop	hl
.after_del_move:
	dec	b	; characters to left -= 1
	call	HIDE_CURSOR
	push	hl
	ld	a,0b01111000	; black ink, white paper
	call	PRINT_WRAP
	pop	hl
	call	MOVE_CURSOR
	ret

	; Renders multiple lines of text, until the end of the buffer:
	; Takes:
	; A = attr, B = char count, DE = char pointer, HL = initial coords
	; HL' coords of start of line.
	; RETURNS:
	; HL = coords of the end of last line.
	; On stack: start of last line.
PRINT_WRAP:
	push	bc
	push	de
	ld	b,c	; b := total characters to render.
	exx
	push	hl	; Push start of line.
	exx
	jr	.first_line

.next_line:	pop	hl	; Pop start of line.
	inc	h	; Down one line
	push	hl	; Push start of line.
.first_line:
	call	RENDER_TEXT	; Render as much as we can (stopping at end of line)
	
	push	bc
	push	de
	ld	de, .two_spaces
	ld	b,2
	call	RENDER_TEXT	; Erase any junk at end of line.
	pop	de	; de := next character (start of next line)
	pop	bc	; b := remaining characters to render

	inc	b
	djnz	.next_line	; Loop if more characters (lines) to render.
	pop	de	; pop (and discard) start-of-line (was HL)
	pop	de
	pop	bc
	ret

.two_spaces	db	' ', ' '

CURSOR_LEFT:
	dec	b
	inc	b
	ret	z	; We’ve hit the left limit

	dec	b	; 1 more left
	inc	c	; 1 less right
	dec	de	; Back 1 char byte
	ld	a,(de)	; Get prev char
	call	MEASURE_CHAR	; Width in half-cells
	neg
	add	l
	ld	l,a
	jr	HIDE_AND_LD_CUR	; (Tail call)

CURSOR_RIGHT:
	dec	c
	inc	c
	ret	z	; We’ve hit the right limit

	dec	c	; 1 more right
	inc	b	; 1 less left
	ld	a,(de)	; Get current char
	call	MEASURE_CHAR	; Width in half-cells
	inc	de	; Forward 1 char byte
	add	l
	ld	l,a
	jr	HIDE_AND_LD_CUR	; (Tail call)

CURSOR_UP:	; TODO
	ret

CURSOR_DOWN:	; TODO
	ret

HIDE_AND_LD_CUR:	call	HIDE_CURSOR
	ld	(CURSOR_XY), hl
	ret

	; Moves cursor to coordinates indicated by HL
	; Trashes A
MOVE_CURSOR:	call	HIDE_CURSOR
	ld	(CURSOR_XY), hl
	jp	SHOW_CURSOR	; Tail call.

	; Display cursor on the screen, if it is not already shown.
	; Either way, extend animation frame count for visible cursor.
	; (Extend the displayed lifespan.)
	; Trashes: A
SHOW_CURSOR:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	ld	(hl), (CURSOR_FLASH_RATE << 1) | 1
	rra		; Examine previous value of bit zero…
	jr	nc,CURSOR_XOR.after_pushes_HL
	pop	hl
	ret

	; Hide the cursor, if it is shown.
	; Trashes: A
HIDE_CURSOR:
	ld	a, (CURSOR_FRAMES)
	rra
	ret	nc	; Cursor not on screen anyway
	xor	a	; Cursor WAS on screen…
	ld	(CURSOR_FRAMES), a	; And store back in variable.
	jr	CURSOR_XOR

	; Decrement the frame counter and show or hide the cursor
	; Trashes: A
CURSOR_ANIM_FRAME:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	srl	a
	dec	a
	jr	z, .statechange
	rla		; Put <carry> back into posn 0
	ld	(hl), a	; And store back in variable.
	pop	hl
	ret
.statechange:
	rla		; Move <carry> back into low bit
	xor	(CURSOR_FLASH_RATE << 1) | 1	; Add back in count and invert bit zero
.store_and_xor:	ld	(hl), a
	jr	CURSOR_XOR.after_pushes_HL

	; Invert cursor pixels. Current cursor posn is held in (CURSOR_XY)
	; Trashes: A
CURSOR_XOR:
	push	hl
.after_pushes_HL
	push	de
	push	bc
	ld	b, 8
	ld	hl, (CURSOR_XY)
	call	ROWCOL_ADDR
	bit	5, d
	jr	nz, .halfcol
.cellboundary:
.loop0:	ld	a, (de)
	xor	0b10000000
	ld	(de), a
	inc	d
	djnz	.loop0
	dec	e
	jp	m,.pop_and_return	; Return if we were in the first column
	ld	b, 8	; Otherwise…
.loop0B:	dec	d
	ld	a, (de)
	xor	1
	ld	(de), a
	djnz	.loop0B
.pop_and_return:
	pop	bc
	pop	de
	pop	hl
	ret
.halfcol:
	res	5, d
.loop1:	ld	a, (de)
	xor	0b00011000
	ld	(de), a
	inc	d
	djnz	.loop1
	jr	.pop_and_return