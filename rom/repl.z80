	; Read-Execute-Print Loop
POP_AND_REPL:
	pop	bc	; Pop off a return address
REPL:
.cls
	ld	a,7
	out	($fe),a	; Set border to white
	ld	hl,$5800
	ld	(hl),0b00111111	; White ink; white paper
	ld	de,$5801
	ld	bc,768
	ldir		; Clear screen to all white (16123 t-states)
.init_buffer
	ld	de, $5B80
	ld	b, 0
	ld	hl, $0300
	ld	(CURSOR_XY), hl
REPL_LOOP:	
.check_key:
	ld	a, (KEY_CHAR)
	or	a
	jr	nz,.keypress
.await	halt		; Wait for some potential keyboard input.
	call	CURSOR_ANIM_FRAME
	jr	.check_key
.keypress
	ld	(de), a
	inc	de
	inc	b
.print_it:
	call	HIDE_CURSOR
	push	de
	push	bc
	push	hl
	ld	de, $5B80
	ld	a, 0b01111000
	call	render_text
	ld	(CURSOR_XY), hl
	call	SHOW_CURSOR
	pop	hl
	pop	bc
	pop	de
	jr	.await

	; Display cursor on the screen, if it is not already shown.
	; Either way, extend animation frame count for visible cursor.
	; (Extend the displayed lifespan.)
	; Trashes: A, HL
SHOW_CURSOR:
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	ld	(hl), (CURSOR_FLASH_RATE << 1) | 1
	rra		; Examine previous value of bit zero…
	ret	c	; Exit if cursor already shown
	jr	CURSOR_XOR

	; Hide the cursor, if it is shown.
	; Trashes: A
HIDE_CURSOR:
	ld	a, (CURSOR_FRAMES)
	rra
	ret	nc	; Cursor not on screen anyway
	xor	a	; Cursor WAS on screen…
	ld	(CURSOR_FRAMES), a	; And store back in variable.
	jr	CURSOR_XOR

	; Decrement the frame counter and show or hide the cursor
	; Trashes: A
CURSOR_ANIM_FRAME:
	push	hl
	ld	hl, CURSOR_FRAMES
	ld	a, (hl)
	srl	a
	dec	a
	jr	z, .statechange
	rla		; Put <carry> back into posn 0
	ld	(hl), a	; And store back in variable.
	pop	hl
	ret
.statechange:
	rla		; Move <carry> back into low bit
	xor	(CURSOR_FLASH_RATE << 1) | 1	; Add back in count and invert bit zero
.store_and_xor:	ld	(hl), a
	jr	CURSOR_XOR.after_pushes_HL

	; Invert cursor pixels. Current cursor posn is held in (CURSOR_XY)
	; Trashes: A
CURSOR_XOR:
	push	hl
.after_pushes_HL
	push	de
	push	bc
	ld	b, 8
	ld	hl, (CURSOR_XY)
	call	ROWCOL_ADDR
	bit	5, d
	jr	nz, .halfcol
.cellboundary:
.loop0:	ld	a, (de)
	xor	0b10000000
	ld	(de), a
	inc	d
	djnz	.loop0
	dec	e
	jp	m,.pop_and_return	; Return if we were in the first column
	ld	b, 8	; Otherwise…
.loop0B:	dec	d
	ld	a, (de)
	xor	1
	ld	(de), a
	djnz	.loop0B
.pop_and_return:
	pop	bc
	pop	de
	pop	hl
	ret
.halfcol:
	res	5, d
.loop1:	ld	a, (de)
	xor	0b00011000
	ld	(de), a
	inc	d
	djnz	.loop1
	jr	.pop_and_return