	PADTO	$0600

	; Render some text
	; de	= pointer to characters
	; b	= count of characters
	; hl	= row/column (h = row 0–23; l = column 0–63)
render_text:
	push	hl
	inc	b		; b := characters to print + 1
	exx			; de' := char pointer; b' := remaining character count
	pop	hl		; hl := row/column
	; get screen position pointer into BC from HL coordinates
	ld	bc, $4000	; (FAKE)
	jp	render_common_char

render_next_char:
	ld	a, -8
	add	d
	ld	b, a
	ld	c, e
render_next_char_same_line:
	; <check haven’t gone off end of 32-character line>

render_common_char:
	exx			; de := char pointer; b := remaining characters + 1; bc' := screen pointer
	dec	b
	ret	z
	ld	a, (de)		; a := next character to render
	inc	de

	exx			; bc := screen pointer
	ld	hl, FONT_LOOKUP	; Character index table

	; Force character (in A) to be in range of glyphs:
	sub	(hl)		; First character represented
	jr	nc, rep1
	xor	a
rep1:	inc	hl
	cp	(hl)		; #number characters represented
	jr	c, rep2
	xor	a
rep2:	inc hl

	; Look up glyph data:
	ld	e, a
	ld	d, 0
	add	hl, de
	add	hl, de
	ld	a, (hl)		; LOW byte of character data pointer
	inc	hl
	ld	h, (hl)		; HIGH byte of character data pointer
	ld	l, a		; hl := character pointer

	ld	d, b
	ld	e, c		; de := screen pointer

	; Decode character info:
	ld	b, (hl)		; <char-info> = binary <widthnybles:2><startrow:3><height:3>
	inc	hl		; Advance to pixel data
	ld	a, b
	ex	af, af'		; a' := <char-info>
	ld	a, 7
	and	b
	ld	c, a		; c := <height:3>
	ld	a, b
	rra
	rra
	rra
	and	7
	ld	b, a		; b := <startrow:3>

	ld	a, 8
	sub	b
	sub	c
	sub	c
	ex	af, af'		; a := <chr-info>; a' := (8 - startrow - height)
	rla
	jr	nc, render_w0w1
render_w2w3:
	rla
	jr	c, render_w3

	; RENDER 8-BIT GLYPH AT NO OFFSET
render_w2:
	xor	a
	cp	b
	jr	z, r_w2_top_end
r_w2_top:
	ld	(de), a
	inc	d
	djnz	r_w2_top
r_w2_top_end:
	ld	b, c
r_w2_mid:
	ld	a, (hl)
	ld	(de), a
	inc	hl
	inc	d
	ld	a, (hl)
	ld	(de), a
	inc	hl
	inc	d
	djnz	r_w2_mid

	ex	af, af'		; a := remaining blank rows (flags should also be set appropriately)
	jr	z, r_w2_bot_end
	ld	b, a
	xor	a
r_w2_bot:
	ld	(de), a
	inc	d
	djnz	r_w2_bot
r_w2_bot_end:
	inc	e		; move to next column
	jp	render_next_char

	; RENDER 12-BIT GLYPH AT NO OFFSET
render_w3:
	xor	a
	cp	b
	jr	z, r_w3_top_end
r_w3_top:
	ld	(de), a
	inc	e
	ld	(de), a
	dec	e
	inc	d
	djnz	r_w3_top
r_w3_top_end:
	ld	b, c
r_w3_mid:
	ld	a, (hl)
	inc	hl
	ld	c, (hl)
	inc	hl
	ld	(de), a
	inc	e
	ld	a, c
	ld	(de), a
	inc	d
	ld	c, (hl)
	inc	hl
	ld	a, (hl)
	inc	hl
	ld	(de), a
	dec	e
	ld	a, c
	ld	(de), a
	inc	d
	djnz	r_w3_mid

	ex	af, af'		; a := remaining blank rows (flags should also be set appropriately)
	jr	z, r_w3_bot_end
	ld	b, a
	xor	a
r_w3_bot:
	ld	(de), a
	inc	e
	ld	(de), a
	dec	e
	inc	d
	djnz	r_w3_bot
r_w3_bot_end:
	inc	e		; move to next column
	inc	e
	jp	render_next_char

render_w0w1:
	rla
	jp	nc, render_next_char_same_line

	; RENDER 4-BIT GLYPH AT NO OFFSET
render_w1:
	xor	a
	cp	b
	jr	z, r_w1_top_end
r_w1_top:
	ld	(de), a
	inc	d
	djnz	r_w1_top
r_w1_top_end:
	ld	b, c
	ld	c, $f0
r_w1_mid:
	ld	a, (hl)
	and	c
	ld	(de), a
	inc	hl
	inc	d
	ld	a, (hl)
	and	c
	ld	(de), a
	inc	hl
	inc	d
	djnz	r_w1_mid

	ex	af, af'
	or	a
	jr	z, r_w1_bot_end
	ld	b, a
	xor	a
r_w1_bot:
	ld	(de), a
	inc	d
	djnz	r_w1_bot
r_w1_bot_end:
	inc	e		; move to next column
	jp	render_next_char



/*
	; Alternate version where bitmask determines which rows have character data:
	ld	a, (hl)		; <char-info> = binary <widthnybles:2><startrow:3><height:3>
	inc	hl		; Advance to pixel data
	ld	c, (hl)
	inc	hl
	rla
	jr	nc, render_w0w1
render_w2w3:
	rla
	jr	c, render_w3

render_w2:
	xor	a
	ld	b, 4
r_w2_loop:
	srl	c
	jr	nc, r_w2_cont
	ld	a, (hl)
	inc	hl
r_w2_cont:
	ld	(de), a
	inc	d
	djnz	r_w2_loop
	jp	render_next_char
*/

/*
	ld	a, (bc)	; Get bits of glyph
	inc	bc	; Next bits
	ld	e, a	; Prepare to look up rotation
	ld	a, (de)	; Grab shifted-right bits
	or	(hl)
	ld	(hl), a	; Merge shifted glyph into screen
	inc	l
	inc	d
	ld	a, (de)
	ld	(hl), a
	inc	h
	dec	d
*/