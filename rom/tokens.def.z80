TOK_END	EQU 0
TOK_NONE	EQU 0

; Operators:
TOK_EQ	EQU 1	; =
TOK_NE	EQU 2	; ≠
TOK_LT	EQU 3	; <
TOK_LE	EQU 4	; ≤
TOK_GT	EQU 5	; >
TOK_GE	EQU 6	; ≥
; Arithmetic:
TOK_ADD	EQU 7	; +
TOK_SUB	EQU 8	; –
TOK_MUL	EQU 9	; ×
TOK_DIV	EQU 10	; /
TOK_FLOORDIV	EQU 11	; //
TOK_MOD	EQU 12	; %
TOK_EXP	EQU 13	; **
; Bit operators:
TOK_BITAND	EQU 14	; &
TOK_BITOR	EQU 15	; |
TOK_BITINV	EQU 16	; ~ [unary operator]
TOK_BITSL	EQU 17	; <<
TOK_BITSR	EQU 18	; >>
TOK_BITXOR	EQU 19	; ^

TOK_EXTRASPACE	EQU 20	; ' '

; These tokens are alternate versions of operators. Can usually subtract 24 to get to canonical:
; TODO: Could possibly arrange these to fall in an 16-aligned block… easier to test for.
TOK_X0_NE	EQU 21	; <>	(Canonical glyph is ‘≠’)
TOK_X_NE	EQU 21+TOK_NE	; !=	(Canonical glyph is ‘≠’)
TOK_X_LE	EQU 21+TOK_LE	; <=	(Canonical glyph is ‘≤’)
TOK_X_GE	EQU 21+TOK_GE	; >=	(Canonical glyph is ‘≥’)
TOK_X_SUB	EQU 21+TOK_SUB	; -	(Canonical glyph is n-dash for minus, not hyphen)
TOK_X_MUL	EQU 21+TOK_MUL	; *	(Canonical glyph is cross-multiply symbol, not asterisk)

TOK_X_PI	EQU 31	; ‘pi’	(Canonical is ‘π’)
TOK_PI	EQU 32	; π

AFTER_OPERATORS	EQU 33
TOK_SEMICOLON	EQU 33	; ;
TOK_COLON	EQU 34	; :
TOK_COMMA	EQU 35	; ,
TOK_ARROPEN	EQU 36	; [
TOK_ARRCLOSE	EQU 37	; ]
TOK_PARENOPEN	EQU 38	; (
TOK_PARENCLOSE	EQU 39	; )
TOK_DOT	EQU 40	; .

TOK_DISCARD	EQU 41	; _

AFTER_PUNCTUATION	EQU 42
TOK_AND	EQU 42	; and
TOK_OR	EQU 43	; or
TOK_NOT	EQU 44	; not [unary operator]
TOK_FALSE	EQU 45	; false
TOK_TRUE	EQU 46	; true

AFTER_BOOLEANS	EQU 47
TOK_BREAK	EQU 47	; break
TOK_CONTINUE	EQU 48	; continue
TOK_ELIF	EQU 49	; elif
TOK_ELSE	EQU 50	; else
TOK_FOR	EQU 51	; for
TOK_IF	EQU 52	; if
TOK_IN	EQU 53	; in
TOK_LOOP	EQU 54	; loop
TOK_PASS	EQU 55	; pass
TOK_RETURN	EQU 56	; return
TOK_WHILE	EQU 57	; while

AFTER_CONTROLFLOW	EQU 58
TOK_LET	EQU 58	; let
TOK_DEF	EQU 59	; def
TOK_IMPORT	EQU 60	; import
TOK_AS	EQU 61	; as

AFTER_DEFINITION	EQU 62
TOK_END_SIMPLE	EQU 62

; Each of these followed by <length> byte and <offset> byte (to text buffer)
; The XXXX1 variants are for single-character tokens, which do not need a length byte.
TOK_RAW_INVALID	EQU $60	; Unrecognised token.
TOK_RAW_INVALID1	EQU $61	; Unrecognised token.
TOK_RAW_COMMENT	EQU $62	; # to end of line
TOK_RAW_COMMENT1	EQU $63	; # to end of line
TOK_RAW_IDENT	EQU $64
TOK_RAW_IDENT1	EQU $65
TOK_RAW_STRING	EQU $66
TOK_RAW_REAL	EQU $68
TOK_RAW_DECINT	EQU $6a
TOK_RAW_DECINT1	EQU $6b
TOK_RAW_HEXINT	EQU $6c
TOK_RAW_BININT	EQU $6e

TOK_IDENTIFIER	EQU $f0
TOK_STRING	EQU $f1
TOK_COMMENT	EQU $f2	; # to end of line
